# 30. ドキュメント管理

## ドキュメント体系

### 基本構造

```
docs/
├── prd/              # Product Requirements Documents
├── adr/              # Architecture Decision Records
├── tech/             # 技術文書
├── api/              # API仕様書
├── operations/       # 運用文書
└── user/             # ユーザーガイド
```

### ドキュメントタイプ別ルール

#### PRD (Product Requirements Document)
**配置場所**: `docs/prd/`
**ファイル名**: 内容がわかりやすい命名

```
docs/prd/
├── main-features.md      # 主要機能要件
├── mvp-requirements.md   # MVP要件
├── user-stories.md       # ユーザーストーリー
└── acceptance-criteria.md # 受け入れ基準
```

**テンプレート**:
```markdown
# [機能名] 要件定義

## 概要
この機能の目的と背景

## 機能要件
### 必須機能
- 機能1: 説明
- 機能2: 説明

### 推奨機能
- 機能A: 説明

## 非機能要件
### パフォーマンス
- レスポンス時間: 2秒以内

### セキュリティ
- 認証: JWT認証

## 受け入れ基準
### シナリオ1
- 条件: ユーザーがログインしている
- 実行: ログイン情報を確認する
- 結果: ユーザー情報が表示される
```

#### ADR (Architecture Decision Records)
**配置場所**: `docs/adr/`
**ファイル名**: `{連番}-{決定内容}.md`

```
docs/adr/
├── 001-initial-architecture.md
├── 002-testing-strategy.md
├── 003-database-selection.md
└── 004-authentication-method.md
```

**テンプレート**:
```markdown
# ADR-001: 初期アーキテクチャの決定

## ステータス
採用済み

## 背景
なぜこの決定が必要だったのか

## 検討した選択肢
### 選択肢1: マイクロサービスアーキテクチャ
**メリット**:
- スケーラビリティが高い
- 独立したデプロイが可能

**デメリット**:
- 複雑性が増加
- 運用コストが高い

### 選択肢2: モノリシックアーキテクチャ
**メリット**:
- 開発・テストが簡単
- 運用が単純

**デメリット**:
- スケーラビリティに限界

## 決定
モノリシックアーキテクチャを採用

## 理由
- チーム規模が小さい（3名）
- 初期段階でのシンプルさを優先
- 運用リソースが限定的

## 結果
- 開発速度が向上
- 運用負荷が軽減
- 将来的にマイクロサービスへの移行を検討
```

#### 技術文書
**配置場所**: `docs/tech/`

```
docs/tech/
├── database-schema.md     # データベース設計
├── api-design.md         # API設計
├── security-design.md    # セキュリティ設計
└── performance-guide.md  # パフォーマンス指針
```

#### API仕様書
**配置場所**: `docs/api/`

```markdown
# API仕様書

## エンドポイント一覧

### ユーザー管理
#### POST /api/users
ユーザーを作成する

**リクエスト**:
```json
{
  "name": "田中太郎",
  "email": "tanaka@example.com",
  "password": "secure_password"
}
```

**レスポンス**:
```json
{
  "success": true,
  "user": {
    "id": 1,
    "name": "田中太郎",
    "email": "tanaka@example.com",
    "created_at": "2024-01-01T00:00:00Z"
  }
}
```

**エラーレスポンス**:
```json
{
  "success": false,
  "error": "メールアドレスは必須です",
  "code": "VALIDATION_ERROR"
}
```
```

### ドキュメントメンテナンス

#### 更新頻度
- **PRD**: 要件変更時に即座に更新
- **ADR**: アーキテクチャ決定時に作成、変更時は新しいADRで対応
- **技術文書**: 実装変更時に同期して更新
- **API仕様書**: API変更時に即座に更新

#### 品質基準
- **目的の明確性**: なぜそのドキュメントが必要かが明確
- **対象読者**: 読み手のレベルに適した内容
- **実装との同期**: 実際の実装と乖離していない
- **日本語記述**: すべて日本語で記述
- **更新日付**: 最終更新日が記載されている

### ファイル命名規則

#### ADR命名
```
{3桁連番}-{決定内容を表すキーワード}.md

例:
001-initial-architecture.md
002-testing-framework-selection.md
003-deployment-strategy.md
```

#### PRD命名
```
{機能域}-{内容}.md

例:
auth-requirements.md
payment-features.md
admin-panel-specs.md
```

#### 技術文書命名
```
{分野}-{内容}.md

例:
database-schema.md
api-specification.md
deployment-guide.md
security-guidelines.md
```

### Claude Code でのドキュメント管理

#### 作成時のルール
- ドキュメント作成要求時は必ず適切な `docs/` 配下に配置
- 新規ドキュメントは明示的な要求時のみ作成
- テンプレートに従って構造化されたドキュメントを作成

#### 参照時のルール
- 既存ドキュメントの参照時は正しいパスを使用
- 関連ドキュメントの存在を確認し、整合性をチェック
- ドキュメント間のリンクを適切に設定

#### 更新時のルール
- ドキュメント更新時は関連ファイルとの整合性を確認
- 更新理由を明確にして、変更履歴を管理
- 影響範囲を特定し、関連ドキュメントも併せて更新

### バージョン管理

#### Gitでの管理
```bash
# ドキュメント変更のコミットメッセージ例
git commit -m "文書: API仕様書にユーザー削除エンドポイントを追加"
git commit -m "文書: ADR-005データベース選定の決定を追加"
git commit -m "改善: PRDの受け入れ基準を詳細化"
```

#### 変更追跡
- ドキュメント内に最終更新日を記載
- 重要な変更時は変更履歴セクションを追加
- ADRは変更せず、新しいADRで上書き決定を記録

### ドキュメント品質チェック

#### レビューポイント
- [ ] 目的が明確に記載されているか
- [ ] 対象読者が適切に設定されているか
- [ ] 内容が実装と一致しているか
- [ ] 日本語が正しく使用されているか
- [ ] 図表が適切に配置されているか
- [ ] リンクが正常に動作するか

#### 定期メンテナンス
- **月次**: ドキュメントと実装の乖離チェック
- **四半期**: ドキュメント体系の見直し
- **リリース前**: 関連ドキュメントの更新確認

### ドキュメント活用

#### 新規メンバーオンボーディング
1. README.md → プロジェクト概要理解
2. docs/prd/ → 要件理解
3. docs/adr/ → アーキテクチャ決定理解
4. docs/tech/ → 技術詳細理解

#### 意思決定支援
- ADRを参照して過去の決定理由を確認
- PRDで要件の優先度を確認
- 技術文書で実装方針を確認

---

**適用優先度**: 🟡 中（ドキュメント作成・更新時は必須）
**更新頻度**: プロジェクト進行に応じて随時見直し