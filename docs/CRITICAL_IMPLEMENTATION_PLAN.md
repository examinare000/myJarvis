# Critical Implementation Plan - ÊúÄÂ∞èÈôêMVPÂÆüË£ÖË®àÁîª

## üéØ ÁõÆÊ®ô

2ÈÄ±Èñì‰ª•ÂÜÖ„Å´ÊúÄÂ∞èÈôê„ÅÆ„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ„ÇíÂÆüË£Ö„Åó„ÄÅ„Éù„Éº„Éà8080„Åß„Ç¢„ÇØ„Çª„ÇπÂèØËÉΩ„Å´„Åô„Çã„ÄÇ

## üìÖ ÂÆüË£Ö„Çπ„Ç±„Ç∏„É•„Éº„É´

### Day 1-2: Âü∫Áõ§„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó
- [ ] Prisma„Çπ„Ç≠„Éº„ÉûÊõ¥Êñ∞„Å®„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥
- [ ] „Éê„ÉÉ„ÇØ„Ç®„É≥„ÉâAPIÂü∫Êú¨ÂÆüË£Ö
- [ ] „Éï„É≠„É≥„Éà„Ç®„É≥„Éâ„Éó„É≠„Ç∏„Çß„ÇØ„ÉàË®≠ÂÆö

### Day 3-5: „Ç≥„Ç¢Ê©üËÉΩÂÆüË£Ö
- [ ] ÂΩìÊó•„Çø„Çπ„ÇØË°®Á§∫Ê©üËÉΩ
- [ ] „É©„Ç§„Éï„É≠„Ç∞ÊäïÁ®ø„ÉªË°®Á§∫Ê©üËÉΩ
- [ ] „ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ„É¨„Ç§„Ç¢„Ç¶„Éà

### Day 6-7: Áµ±Âêà„ÉªÊúÄÈÅ©Âåñ
- [ ] „Éï„É≠„É≥„Éà„Ç®„É≥„Éâ„Å®„Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ„ÅÆÁµ±Âêà
- [ ] „É¨„Çπ„Éù„É≥„Ç∑„ÉñÂØæÂøú
- [ ] „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞

## üì¶ CriticalÂÆüË£Ö„Çø„Çπ„ÇØÔºàÂÑ™ÂÖàÂ∫¶È†ÜÔºâ

### 1. „Éá„Éº„Çø„Éô„Éº„Çπ„Éª„Éê„ÉÉ„ÇØ„Ç®„É≥„ÉâÔºàDay 1Ôºâ

#### „Çø„Çπ„ÇØ: DB-001 Prisma„Çπ„Ç≠„Éº„ÉûÊõ¥Êñ∞
```bash
# ÂÆüË°å„Ç≥„Éû„É≥„Éâ
cd backend
```

```prisma
// backend/prisma/schema.prisma „Å´ËøΩÂä†

model LifelogEntry {
  id           String   @id @default(cuid())
  userId       String
  content      String   @db.VarChar(280)
  tags         String[]
  mood         String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
  @@map("lifelog_entries")
}

model CalendarEvent {
  id             String   @id @default(cuid())
  userId         String
  title          String   @db.VarChar(255)
  description    String?
  startTime      DateTime
  endTime        DateTime
  category       String?  @default("general")
  color          String?  @default("#1976D2")
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([startTime, endTime])
  @@map("calendar_events")
}
```

```bash
# „Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥ÂÆüË°å
npx prisma migrate dev --name add_lifelog_and_calendar
npx prisma generate
```

#### „Çø„Çπ„ÇØ: BE-001 ÊúÄÂ∞èÈôêAPIÂÆüË£Ö

```typescript
// backend/src/routes/lifelog.ts
import { Router } from 'express';
import { PrismaClient } from '@prisma/client';
import { z } from 'zod';

const router = Router();
const prisma = new PrismaClient();

// Validation schema
const createLifelogSchema = z.object({
  content: z.string().min(1).max(280),
  tags: z.array(z.string()).optional(),
  mood: z.enum(['great', 'good', 'okay', 'bad', 'terrible']).optional(),
});

// GET /api/v1/lifelog/entries
router.get('/entries', async (req, res) => {
  try {
    const { limit = 20, offset = 0 } = req.query;

    const entries = await prisma.lifelogEntry.findMany({
      where: { userId: req.user?.id },
      orderBy: { createdAt: 'desc' },
      take: Number(limit),
      skip: Number(offset),
    });

    res.json(entries);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch entries' });
  }
});

// POST /api/v1/lifelog/entries
router.post('/entries', async (req, res) => {
  try {
    const data = createLifelogSchema.parse(req.body);

    const entry = await prisma.lifelogEntry.create({
      data: {
        ...data,
        userId: req.user?.id || 'test-user', // TODO: Ë™çË®ºÂÆüË£ÖÂæå„Å´‰øÆÊ≠£
      },
    });

    res.status(201).json(entry);
  } catch (error) {
    if (error instanceof z.ZodError) {
      res.status(400).json({ errors: error.errors });
    } else {
      res.status(500).json({ error: 'Failed to create entry' });
    }
  }
});

export default router;
```

```typescript
// backend/src/routes/tasks.ts „Å´ËøΩÂä†
// GET /api/v1/tasks/today
router.get('/today', async (req, res) => {
  try {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    const tasks = await prisma.task.findMany({
      where: {
        userId: req.user?.id || 'test-user',
        dueDate: {
          gte: today,
          lt: tomorrow,
        },
      },
      orderBy: [
        { priority: 'desc' },
        { createdAt: 'asc' },
      ],
    });

    res.json(tasks);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch today tasks' });
  }
});
```

### 2. „Éï„É≠„É≥„Éà„Ç®„É≥„ÉâÂü∫Áõ§ÔºàDay 2Ôºâ

#### „Çø„Çπ„ÇØ: FE-001 „Éó„É≠„Ç∏„Çß„ÇØ„ÉàË®≠ÂÆö

```bash
cd frontend
npm install zustand @tanstack/react-query react-hook-form @hookform/resolvers zod
```

```typescript
// frontend/vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { resolve } from 'path';

export default defineConfig({
  plugins: [react()],
  server: {
    port: 8080,  // „Éù„Éº„Éà8080„ÅßËµ∑Âãï
    proxy: {
      '/api': {
        target: 'http://localhost:3001',
        changeOrigin: true,
      }
    }
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src'),
      '@components': resolve(__dirname, 'src/components'),
      '@stores': resolve(__dirname, 'src/stores'),
      '@hooks': resolve(__dirname, 'src/hooks'),
    }
  }
});
```

#### „Çø„Çπ„ÇØ: FE-002 Áä∂ÊÖãÁÆ°ÁêÜ„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó

```typescript
// frontend/src/stores/uiStore.ts
import { create } from 'zustand';

interface UIStore {
  selectedDate: Date;
  taskFilter: 'all' | 'today' | 'week';
  sidebarOpen: boolean;

  setSelectedDate: (date: Date) => void;
  setTaskFilter: (filter: 'all' | 'today' | 'week') => void;
  toggleSidebar: () => void;
}

export const useUIStore = create<UIStore>((set) => ({
  selectedDate: new Date(),
  taskFilter: 'today',
  sidebarOpen: true,

  setSelectedDate: (date) => set({ selectedDate: date }),
  setTaskFilter: (filter) => set({ taskFilter: filter }),
  toggleSidebar: () => set((state) => ({ sidebarOpen: !state.sidebarOpen })),
}));
```

```typescript
// frontend/src/lib/queryClient.ts
import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000,
      retry: 2,
      refetchOnWindowFocus: false,
    },
  },
});
```

### 3. „Ç≥„Ç¢„Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÂÆüË£ÖÔºàDay 3-5Ôºâ

#### „Çø„Çπ„ÇØ: DS-001 „É°„Ç§„É≥„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ

```typescript
// frontend/src/pages/Dashboard.tsx
import React from 'react';
import { Grid, Container, Typography, Box } from '@mui/material';
import { TodayTasksPanel } from '@components/dashboard/TodayTasksPanel';
import { LifelogSection } from '@components/lifelog/LifelogSection';
import { useUIStore } from '@stores/uiStore';

export const Dashboard: React.FC = () => {
  const selectedDate = useUIStore((state) => state.selectedDate);

  return (
    <Container maxWidth="xl" sx={{ py: 3 }}>
      <Box sx={{ mb: 3 }}>
        <Typography variant="h4" component="h1">
          myJarvis Dashboard
        </Typography>
        <Typography variant="body1" color="text.secondary">
          {selectedDate.toLocaleDateString('ja-JP', {
            year: 'numeric',
            month: 'long',
            day: 'numeric',
            weekday: 'long',
          })}
        </Typography>
      </Box>

      <Grid container spacing={3}>
        {/* ÂΩìÊó•„Çø„Çπ„ÇØ */}
        <Grid item xs={12} md={6} lg={4}>
          <TodayTasksPanel />
        </Grid>

        {/* „É©„Ç§„Éï„É≠„Ç∞ */}
        <Grid item xs={12} md={6} lg={8}>
          <LifelogSection />
        </Grid>
      </Grid>
    </Container>
  );
};
```

#### „Çø„Çπ„ÇØ: DS-002 ÂΩìÊó•„Çø„Çπ„ÇØ„Éë„Éç„É´

```typescript
// frontend/src/components/dashboard/TodayTasksPanel.tsx
import React from 'react';
import {
  Card,
  CardHeader,
  CardContent,
  List,
  LinearProgress,
  Typography,
  Box,
  Skeleton,
} from '@mui/material';
import { TaskQuickCard } from './TaskQuickCard';
import { useTodayTasks } from '@hooks/queries/useTasks';

export const TodayTasksPanel: React.FC = () => {
  const { data: tasks, isLoading } = useTodayTasks();

  const completedCount = tasks?.filter(t => t.status === 'DONE').length || 0;
  const totalCount = tasks?.length || 0;
  const completionRate = totalCount > 0 ? (completedCount / totalCount) * 100 : 0;

  return (
    <Card>
      <CardHeader
        title="‰ªäÊó•„ÅÆ„Çø„Çπ„ÇØ"
        subheader={
          <Box sx={{ mt: 1 }}>
            <LinearProgress
              variant="determinate"
              value={completionRate}
              sx={{ mb: 1 }}
            />
            <Typography variant="body2" color="text.secondary">
              {completedCount}/{totalCount} ÂÆå‰∫Ü ({Math.round(completionRate)}%)
            </Typography>
          </Box>
        }
      />
      <CardContent>
        {isLoading ? (
          <>
            <Skeleton variant="rectangular" height={60} sx={{ mb: 1 }} />
            <Skeleton variant="rectangular" height={60} sx={{ mb: 1 }} />
            <Skeleton variant="rectangular" height={60} />
          </>
        ) : (
          <List disablePadding>
            {tasks?.map(task => (
              <TaskQuickCard key={task.id} task={task} />
            ))}
            {tasks?.length === 0 && (
              <Typography variant="body2" color="text.secondary" align="center">
                ‰ªäÊó•„ÅÆ„Çø„Çπ„ÇØ„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì
              </Typography>
            )}
          </List>
        )}
      </CardContent>
    </Card>
  );
};
```

#### „Çø„Çπ„ÇØ: LF-001 „É©„Ç§„Éï„É≠„Ç∞ÂÖ•Âäõ

```typescript
// frontend/src/components/lifelog/LifelogInput.tsx
import React, { useState } from 'react';
import {
  Card,
  CardContent,
  TextField,
  Button,
  Box,
  Typography,
  IconButton,
  Chip,
} from '@mui/material';
import {
  Send as SendIcon,
  Mood as MoodIcon,
  LocationOn as LocationIcon,
  Image as ImageIcon,
} from '@mui/icons-material';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { useCreateLifelog } from '@hooks/mutations/useLifelog';

const lifelogSchema = z.object({
  content: z.string().min(1, '„ÉÜ„Ç≠„Çπ„Éà„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ').max(280, '280ÊñáÂ≠ó‰ª•ÂÜÖ„ÅßÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ'),
  tags: z.array(z.string()).optional(),
  mood: z.enum(['great', 'good', 'okay', 'bad', 'terrible']).optional(),
});

type LifelogFormData = z.infer<typeof lifelogSchema>;

const moodEmojis = {
  great: 'üòÑ',
  good: 'üòä',
  okay: 'üòê',
  bad: 'üòî',
  terrible: 'üò¢',
};

export const LifelogInput: React.FC = () => {
  const [selectedMood, setSelectedMood] = useState<string | null>(null);
  const createLifelog = useCreateLifelog();

  const {
    register,
    handleSubmit,
    reset,
    watch,
    formState: { errors },
  } = useForm<LifelogFormData>({
    resolver: zodResolver(lifelogSchema),
  });

  const content = watch('content', '');

  const onSubmit = (data: LifelogFormData) => {
    // „Çø„Ç∞„ÇíËá™ÂãïÊäΩÂá∫
    const tags = content.match(/#\w+/g)?.map(tag => tag.substring(1)) || [];

    createLifelog.mutate(
      {
        ...data,
        tags,
        mood: selectedMood as any,
      },
      {
        onSuccess: () => {
          reset();
          setSelectedMood(null);
        },
      }
    );
  };

  return (
    <Card>
      <CardContent>
        <form onSubmit={handleSubmit(onSubmit)}>
          <TextField
            {...register('content')}
            fullWidth
            multiline
            rows={3}
            placeholder="‰ªä‰Ωï„Åó„Å¶„ÇãÔºü"
            variant="outlined"
            error={!!errors.content}
            helperText={errors.content?.message || `${content.length}/280`}
            sx={{ mb: 2 }}
          />

          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <Box sx={{ display: 'flex', gap: 1 }}>
              {Object.entries(moodEmojis).map(([mood, emoji]) => (
                <IconButton
                  key={mood}
                  onClick={() => setSelectedMood(mood === selectedMood ? null : mood)}
                  sx={{
                    bgcolor: mood === selectedMood ? 'primary.light' : 'transparent',
                  }}
                >
                  <Typography fontSize={20}>{emoji}</Typography>
                </IconButton>
              ))}
            </Box>

            <Button
              type="submit"
              variant="contained"
              endIcon={<SendIcon />}
              disabled={!content.trim() || createLifelog.isPending}
            >
              ÊäïÁ®ø
            </Button>
          </Box>
        </form>
      </CardContent>
    </Card>
  );
};
```

### 4. API HooksÂÆüË£ÖÔºàDay 4Ôºâ

```typescript
// frontend/src/hooks/queries/useTasks.ts
import { useQuery } from '@tanstack/react-query';
import { apiClient } from '@/lib/apiClient';

export const useTodayTasks = () => {
  return useQuery({
    queryKey: ['tasks', 'today'],
    queryFn: async () => {
      const response = await apiClient.get('/api/v1/tasks/today');
      return response.data;
    },
  });
};
```

```typescript
// frontend/src/hooks/queries/useLifelog.ts
import { useQuery, useInfiniteQuery } from '@tanstack/react-query';
import { apiClient } from '@/lib/apiClient';

export const useLifelogEntries = () => {
  return useInfiniteQuery({
    queryKey: ['lifelog', 'entries'],
    queryFn: async ({ pageParam = 0 }) => {
      const response = await apiClient.get('/api/v1/lifelog/entries', {
        params: { limit: 20, offset: pageParam },
      });
      return response.data;
    },
    getNextPageParam: (lastPage, pages) => {
      if (lastPage.length < 20) return undefined;
      return pages.length * 20;
    },
  });
};
```

```typescript
// frontend/src/hooks/mutations/useLifelog.ts
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { apiClient } from '@/lib/apiClient';

export const useCreateLifelog = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (data: any) => {
      const response = await apiClient.post('/api/v1/lifelog/entries', data);
      return response.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['lifelog', 'entries'] });
    },
  });
};
```

### 5. Áµ±Âêà„ÉªËµ∑Âãï„Çπ„ÇØ„É™„Éó„ÉàÔºàDay 5Ôºâ

```json
// frontend/package.json
{
  "scripts": {
    "dev": "vite --port 8080",
    "build": "tsc && vite build",
    "preview": "vite preview --port 8080",
    "lint": "eslint src --ext ts,tsx",
    "type-check": "tsc --noEmit"
  }
}
```

```bash
# Ëµ∑Âãï„Çπ„ÇØ„É™„Éó„Éà
# start.sh
#!/bin/bash

echo "üöÄ Starting myJarvis Dashboard..."

# PostgreSQLËµ∑Âãï
echo "Starting PostgreSQL..."
docker compose up -d postgres

# „Éê„ÉÉ„ÇØ„Ç®„É≥„ÉâËµ∑Âãï
echo "Starting Backend..."
cd backend
npm run dev &
BACKEND_PID=$!

# „Éï„É≠„É≥„Éà„Ç®„É≥„ÉâËµ∑ÂãïÔºà„Éù„Éº„Éà8080Ôºâ
echo "Starting Frontend on port 8080..."
cd ../frontend
npm run dev &
FRONTEND_PID=$!

echo "‚úÖ myJarvis is running!"
echo "üì± Dashboard: http://localhost:8080"
echo "üîß Backend API: http://localhost:3001"
echo ""
echo "Press Ctrl+C to stop all services..."

# ÁµÇ‰∫ÜÂá¶ÁêÜ
trap "kill $BACKEND_PID $FRONTEND_PID; docker compose down" EXIT

wait
```

## üöÄ Ëµ∑ÂãïÊâãÈ†Ü

```bash
# 1. „Éá„Éº„Çø„Éô„Éº„Çπ„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥
cd backend
npx prisma migrate dev

# 2. ‰æùÂ≠òÈñ¢‰øÇ„Ç§„É≥„Çπ„Éà„Éº„É´
npm install
cd ../frontend
npm install

# 3. Ëµ∑Âãï
cd ..
chmod +x start.sh
./start.sh
```

## ‚úÖ ÂÆå‰∫ÜÂü∫Ê∫ñ

### Day 7ÁµÇ‰∫ÜÊôÇÁÇπ„Åß‰ª•‰∏ã„ÇíÈÅîÊàê:

1. **Ê©üËÉΩË¶Å‰ª∂**
   - [ ] ÂΩìÊó•„Çø„Çπ„ÇØ„ÅåË°®Á§∫„Åï„Çå„Çã
   - [ ] „Çø„Çπ„ÇØ„ÅÆÂÆå‰∫Ü/Êú™ÂÆå‰∫Ü„ÅåÂàá„ÇäÊõø„Åà„Çâ„Çå„Çã
   - [ ] „É©„Ç§„Éï„É≠„Ç∞„ÅåÊäïÁ®ø„Åß„Åç„Çã
   - [ ] „É©„Ç§„Éï„É≠„Ç∞„ÅÆ„Çø„Ç§„É†„É©„Ç§„É≥„ÅåË°®Á§∫„Åï„Çå„Çã
   - [ ] „É¨„Çπ„Éù„É≥„Ç∑„ÉñÂØæÂøúÔºà„É¢„Éê„Ç§„É´/„Éá„Çπ„ÇØ„Éà„ÉÉ„ÉóÔºâ

2. **ÊäÄË°ìË¶Å‰ª∂**
   - [ ] „Éï„É≠„É≥„Éà„Ç®„É≥„Éâ„Åå„Éù„Éº„Éà8080„ÅßÂãï‰Ωú
   - [ ] „Éê„ÉÉ„ÇØ„Ç®„É≥„ÉâAPI„Å®Ê≠£Â∏∏„Å´ÈÄö‰ø°
   - [ ] „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞ÂÆüË£Ö
   - [ ] Âü∫Êú¨ÁöÑ„Å™„É≠„Éº„Éá„Ç£„É≥„Ç∞Ë°®Á§∫

3. **„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ**
   - [ ] ÂàùÊúüË™≠„ÅøËæº„Åø3Áßí‰ª•ÂÜÖ
   - [ ] APIÂøúÁ≠î2Áßí‰ª•ÂÜÖ

## üìù Ê¨°„ÅÆ„Éï„Çß„Éº„Ç∫

CriticalÂÆüË£ÖÂÆå‰∫ÜÂæå:
1. „Ç´„É¨„É≥„ÉÄ„Éº„Éì„É•„ÉºËøΩÂä†ÔºàFullCalendarÁµ±ÂêàÔºâ
2. Ëá™ÁÑ∂Ë®ÄË™ûÂÖ•ÂäõÊ©üËÉΩ
3. Ë©≥Á¥∞„Å™„Éï„Ç£„É´„Çø„Éº„ÉªÊ§úÁ¥¢Ê©üËÉΩ
4. AIÁµ±ÂêàÊ©üËÉΩ

---

„Åì„ÅÆË®àÁîª„Å´Âæì„Å£„Å¶„ÄÅÊúÄÂ∞èÈôê„ÅÆMVP„Çí7Êó•Èñì„ÅßÂÆüË£Ö„Åó„ÄÅ„Éù„Éº„Éà8080„Åß„Ç¢„ÇØ„Çª„ÇπÂèØËÉΩ„Å™„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ„ÇíÊßãÁØâ„Åô„Çã„ÄÇ