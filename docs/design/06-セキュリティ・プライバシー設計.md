# セキュリティ・プライバシー設計書

**バージョン:** 1.0
**日付:** 2025-09-25
**ステータス:** 初版
**作成者:** 開発チーム

## 1. 概要と目的

### 1.1 概要
本設計書は、myJarvis個人AIアシスタントにおけるセキュリティとプライバシー保護の包括的な設計を定義します。「プライバシーバイデザイン」の原則に基づき、ユーザーの機微な情報を最大限保護しながら、システムの機能性を両立させます。

### 1.2 設計原則
- **プライバシーバイデザイン**: システム設計段階からのプライバシー保護
- **最小権限の原則**: 必要最小限のアクセス権限のみ付与
- **データ最小化**: 必要最小限のデータのみ収集・処理
- **透明性**: ユーザーに対するデータ利用の明確な説明
- **ユーザー制御**: データに対するユーザーの完全なコントロール
- **多層防御**: 複数のセキュリティレイヤーによる保護

### 1.3 対象読者
- セキュリティエンジニア
- プライバシーエンジニア
- システムアーキテクト
- コンプライアンス担当者

## 2. 脅威モデル分析

### 2.1 資産分類

| 資産カテゴリ | 機密度 | 例 | 保護要件 |
|-------------|--------|---|----------|
| **極機密 (Tier 1)** | 最高 | バイタル情報、位置履歴、感情データ | ローカル暗号化保存のみ |
| **機密 (Tier 2)** | 高 | タスク詳細、スケジュール、認証トークン | エンドツーエンド暗号化 |
| **社内機密 (Tier 3)** | 中 | 統計データ、匿名化済みデータ | 標準的暗号化 |
| **公開 (Tier 4)** | 低 | アプリメタデータ、一般設定 | 基本的保護 |

### 2.2 脅威分析 (STRIDE)

#### Spoofing (なりすまし)
- **脅威**: 攻撃者が他のユーザーになりすます
- **対策**: 多要素認証、デバイス認証、生体認証

#### Tampering (改ざん)
- **脅威**: データやコードの不正な変更
- **対策**: データ整合性チェック、コード署名、改ざん検知

#### Repudiation (否認)
- **脅威**: 実行した操作の否認
- **対策**: 監査ログ、デジタル署名、タイムスタンプ

#### Information Disclosure (情報漏洩)
- **脅威**: 機密情報の不正な開示
- **対策**: 暗号化、アクセス制御、データマスキング

#### Denial of Service (サービス拒否)
- **脅威**: システムの可用性阻害
- **対策**: レート制限、DDoS保護、冗長化

#### Elevation of Privilege (権限昇格)
- **脅威**: 権限の不正な取得・昇格
- **対策**: 最小権限原則、権限分離、定期的な権限見直し

## 3. 認証・認可アーキテクチャ

### 3.1 多層認証システム

```
┌─────────────────────────────────────────────────────┐
│                User Authentication                   │
├─────────────────────────────────────────────────────┤
│                                                     │
│  ┌─────────────┐    ┌─────────────┐               │
│  │   Primary   │    │  Secondary  │               │
│  │    Auth     │    │    Auth     │               │
│  │             │    │             │               │
│  │ • Password  │    │ • TOTP      │               │
│  │ • Biometric │    │ • SMS       │               │
│  │ • Device    │    │ • Email     │               │
│  │   Cert      │    │ • Push      │               │
│  └─────────────┘    └─────────────┘               │
│         │                   │                      │
│         └───────┬───────────┘                      │
│                 ▼                                  │
│  ┌─────────────────────────────────────────────┐   │
│  │          JWT Token Generation               │   │
│  │                                             │   │
│  │ • RS256 Signature                           │   │
│  │ • Short-lived Access Token (15 min)        │   │
│  │ • Long-lived Refresh Token (30 days)       │   │
│  │ • Device Binding                            │   │
│  └─────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘
```

### 3.2 JWT実装

```typescript
class JWTManager {
  private readonly algorithm = 'RS256';
  private readonly accessTokenTTL = 15 * 60; // 15分
  private readonly refreshTokenTTL = 30 * 24 * 60 * 60; // 30日

  async generateTokenPair(user: User, device: DeviceInfo): Promise<TokenPair> {
    const now = Math.floor(Date.now() / 1000);

    // アクセストークン
    const accessTokenPayload = {
      sub: user.id,
      iss: 'myjarvis',
      aud: 'myjarvis-client',
      iat: now,
      exp: now + this.accessTokenTTL,
      jti: uuidv4(),

      // ユーザー情報
      email: user.email,
      roles: user.roles,

      // デバイス情報
      device_id: device.id,
      device_type: device.type,

      // セキュリティ情報
      session_id: uuidv4(),
      ip_address: device.ipAddress
    };

    // リフレッシュトークン（最小限の情報のみ）
    const refreshTokenPayload = {
      sub: user.id,
      iss: 'myjarvis',
      aud: 'myjarvis-refresh',
      iat: now,
      exp: now + this.refreshTokenTTL,
      jti: uuidv4(),
      token_type: 'refresh',
      session_id: accessTokenPayload.session_id
    };

    const privateKey = await this.getSigningKey();

    const accessToken = jwt.sign(accessTokenPayload, privateKey, {
      algorithm: this.algorithm
    });

    const refreshToken = jwt.sign(refreshTokenPayload, privateKey, {
      algorithm: this.algorithm
    });

    // リフレッシュトークンのハッシュをDBに保存
    await this.storeRefreshTokenHash(refreshToken, user.id, device.id);

    return {
      accessToken,
      refreshToken,
      expiresIn: this.accessTokenTTL,
      tokenType: 'Bearer'
    };
  }

  async validateToken(token: string, expectedAudience: string): Promise<TokenValidationResult> {
    try {
      const publicKey = await this.getVerificationKey();

      const decoded = jwt.verify(token, publicKey, {
        algorithms: [this.algorithm],
        audience: expectedAudience,
        issuer: 'myjarvis'
      }) as JWTPayload;

      // トークンブラックリスト確認
      if (await this.isTokenBlacklisted(decoded.jti)) {
        return { valid: false, error: 'TOKEN_REVOKED' };
      }

      // セッション有効性確認
      if (!(await this.isSessionValid(decoded.session_id))) {
        return { valid: false, error: 'SESSION_INVALID' };
      }

      return {
        valid: true,
        payload: decoded
      };
    } catch (error) {
      return {
        valid: false,
        error: this.classifyJWTError(error)
      };
    }
  }

  async revokeToken(tokenId: string): Promise<void> {
    const blacklistKey = `blacklist:${tokenId}`;
    const ttl = this.accessTokenTTL;

    await this.redis.setex(blacklistKey, ttl, '1');
  }
}
```

### 3.3 多要素認証 (MFA)

```typescript
class MFAManager {
  // TOTP設定
  async setupTOTP(userId: string): Promise<TOTPSetupResult> {
    const secret = speakeasy.generateSecret({
      name: `myJarvis (${userId})`,
      issuer: 'myJarvis',
      length: 32
    });

    // バックアップコード生成（8桁 x 10個）
    const backupCodes = Array.from({ length: 10 }, () =>
      crypto.randomInt(10000000, 99999999).toString()
    );

    // 暗号化してDB保存
    await this.storeMFASecret(userId, secret.base32, backupCodes);

    return {
      secret: secret.base32,
      qrCode: await QRCode.toDataURL(secret.otpauth_url!),
      backupCodes: backupCodes
    };
  }

  // TOTP検証
  async verifyTOTP(userId: string, token: string, isBackupCode: boolean = false): Promise<boolean> {
    const mfaData = await this.getMFAData(userId);
    if (!mfaData) return false;

    if (isBackupCode) {
      return await this.verifyBackupCode(userId, token);
    }

    // TOTP検証（30秒ウィンドウ、1step前後も許可）
    const verified = speakeasy.totp.verify({
      secret: mfaData.secret,
      token,
      window: 1,
      time: Date.now() / 1000
    });

    if (verified) {
      // リプレイアタック防止のためトークンを記録
      await this.markTOTPUsed(userId, token, Date.now());
    }

    return verified;
  }

  private async verifyBackupCode(userId: string, code: string): Promise<boolean> {
    const hashedCode = this.hashBackupCode(code);

    const result = await this.db.query(`
      UPDATE user_backup_codes
      SET used_at = NOW()
      WHERE user_id = $1 AND code_hash = $2 AND used_at IS NULL
    `, [userId, hashedCode]);

    return result.rowCount > 0;
  }
}
```

### 3.4 デバイス認証

```typescript
class DeviceAuthManager {
  // デバイス証明書生成
  async registerDevice(userId: string, deviceInfo: DeviceInfo): Promise<DeviceCertificate> {
    // デバイス固有の識別子生成
    const deviceFingerprint = this.generateDeviceFingerprint(deviceInfo);

    // 証明書の生成
    const keyPair = crypto.generateKeyPairSync('rsa', {
      modulusLength: 2048
    });

    const certificate = {
      deviceId: uuidv4(),
      userId,
      publicKey: keyPair.publicKey.export({ type: 'pkcs1', format: 'pem' }),
      fingerprint: deviceFingerprint,
      name: deviceInfo.name,
      type: deviceInfo.type,
      createdAt: new Date(),
      expiresAt: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000) // 1年
    };

    // 証明書をDBに保存
    await this.storeCertificate(certificate);

    return {
      ...certificate,
      privateKey: keyPair.privateKey.export({ type: 'pkcs1', format: 'pem' })
    };
  }

  // デバイス認証
  async authenticateDevice(deviceId: string, signature: string, challenge: string): Promise<boolean> {
    const certificate = await this.getCertificate(deviceId);
    if (!certificate || certificate.expiresAt < new Date()) {
      return false;
    }

    // 署名検証
    const verify = crypto.createVerify('SHA256');
    verify.update(challenge);

    return verify.verify(certificate.publicKey, signature, 'base64');
  }

  private generateDeviceFingerprint(deviceInfo: DeviceInfo): string {
    const components = [
      deviceInfo.userAgent,
      deviceInfo.screenResolution,
      deviceInfo.timezone,
      deviceInfo.language,
      deviceInfo.platform
    ].filter(Boolean);

    return crypto
      .createHash('sha256')
      .update(components.join('|'))
      .digest('hex');
  }
}
```

## 4. データ保護アーキテクチャ

### 4.1 階層化暗号化システム

```
┌─────────────────────────────────────────────────────────┐
│                Data Protection Layers                   │
├─────────────────────────────────────────────────────────┤
│                                                         │
│ ┌─────────────────────────────────────────────────────┐ │
│ │           Application Layer Encryption              │ │
│ │                                                     │ │
│ │ ┌─────────────┐  ┌─────────────┐  ┌─────────────┐ │ │
│ │ │  Field-     │  │   Payload   │  │   Document  │ │ │
│ │ │  Level      │  │ Encryption  │  │ Encryption  │ │ │
│ │ │ Encryption  │  │ (E2E)       │  │ (Client)    │ │ │
│ │ └─────────────┘  └─────────────┘  └─────────────┘ │ │
│ └─────────────────────────────────────────────────────┘ │
│                           │                             │
│ ┌─────────────────────────▼─────────────────────────────┐ │
│ │           Database Layer Encryption                 │ │
│ │                                                     │ │
│ │ ┌─────────────┐  ┌─────────────┐  ┌─────────────┐ │ │
│ │ │   Column    │  │   Table     │  │ Transparent │ │ │
│ │ │ Encryption  │  │ Encryption  │ │    Data     │ │ │
│ │ │ (AES-256)   │  │             │  │ Encryption  │ │ │
│ │ └─────────────┘  └─────────────┘  └─────────────┘ │ │
│ └─────────────────────────────────────────────────────┘ │
│                           │                             │
│ ┌─────────────────────────▼─────────────────────────────┐ │
│ │             Storage Layer Encryption                │ │
│ │                                                     │ │
│ │ ┌─────────────┐  ┌─────────────┐  ┌─────────────┐ │ │
│ │ │  Hardware   │  │   Volume    │  │   Network   │ │ │
│ │ │ Encryption  │  │ Encryption  │  │ Encryption  │ │ │
│ │ │ (Hardware   │  │  (LUKS)     │  │ (TLS 1.3)   │ │ │
│ │ │   HSM)      │  │             │  │             │ │ │
│ │ └─────────────┘  └─────────────┘  └─────────────┘ │ │
│ └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

### 4.2 暗号化実装

```typescript
class EncryptionManager {
  private readonly algorithm = 'aes-256-gcm';
  private readonly keyDerivationIterations = 100000;

  // ユーザー固有のマスターキー派生
  async deriveUserMasterKey(userId: string, password: string): Promise<Buffer> {
    const salt = await this.getUserSalt(userId);

    return crypto.pbkdf2Sync(
      password,
      salt,
      this.keyDerivationIterations,
      32, // 256 bits
      'sha512'
    );
  }

  // フィールドレベル暗号化
  async encryptField(data: string, userMasterKey: Buffer, context: string): Promise<EncryptedField> {
    // コンテキスト固有の派生キー生成
    const derivedKey = crypto.hkdfSync(
      'sha256',
      userMasterKey,
      Buffer.from(context),
      Buffer.from('myjarvis-field-encryption'),
      32
    );

    const iv = crypto.randomBytes(12);
    const cipher = crypto.createCipher(this.algorithm, derivedKey);
    cipher.setAAD(Buffer.from(context));

    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    return {
      encrypted,
      iv: iv.toString('hex'),
      authTag: cipher.getAuthTag().toString('hex'),
      context
    };
  }

  async decryptField(encryptedField: EncryptedField, userMasterKey: Buffer): Promise<string> {
    const derivedKey = crypto.hkdfSync(
      'sha256',
      userMasterKey,
      Buffer.from(encryptedField.context),
      Buffer.from('myjarvis-field-encryption'),
      32
    );

    const decipher = crypto.createDecipher(this.algorithm, derivedKey);
    decipher.setAAD(Buffer.from(encryptedField.context));
    decipher.setAuthTag(Buffer.from(encryptedField.authTag, 'hex'));

    let decrypted = decipher.update(encryptedField.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }

  // エンドツーエンド暗号化（デバイス間）
  async encryptForDevice(data: any, targetDevicePublicKey: string): Promise<E2EEncryptedPayload> {
    // 対称鍵生成
    const symmetricKey = crypto.randomBytes(32);
    const iv = crypto.randomBytes(12);

    // データを対称鍵で暗号化
    const cipher = crypto.createCipher(this.algorithm, symmetricKey);
    let encryptedData = cipher.update(JSON.stringify(data), 'utf8', 'hex');
    encryptedData += cipher.final('hex');

    // 対称鍵をデバイスの公開鍵で暗号化
    const encryptedKey = crypto.publicEncrypt(
      {
        key: targetDevicePublicKey,
        padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,
        oaepHash: 'sha256'
      },
      symmetricKey
    );

    return {
      encryptedData,
      encryptedKey: encryptedKey.toString('base64'),
      iv: iv.toString('hex'),
      authTag: cipher.getAuthTag().toString('hex')
    };
  }
}
```

### 4.3 キー管理システム

```typescript
class KeyManagementService {
  private readonly keyRotationInterval = 90 * 24 * 60 * 60 * 1000; // 90日

  // ハードウェアセキュリティモジュール統合
  async generateMasterKey(): Promise<KeyMetadata> {
    const keyId = uuidv4();

    if (process.env.NODE_ENV === 'production') {
      // プロダクションではHSMを使用
      const key = await this.hsm.generateKey({
        keyType: 'AES',
        keySize: 256,
        keyUsage: ['encrypt', 'decrypt'],
        extractable: false
      });

      return {
        keyId,
        hsmKeyId: key.id,
        createdAt: new Date(),
        rotationDue: new Date(Date.now() + this.keyRotationInterval)
      };
    } else {
      // 開発環境ではソフトウェア実装
      const key = crypto.randomBytes(32);
      await this.storeKeySecurely(keyId, key);

      return {
        keyId,
        algorithm: 'aes-256-gcm',
        createdAt: new Date(),
        rotationDue: new Date(Date.now() + this.keyRotationInterval)
      };
    }
  }

  // キーローテーション
  async rotateKeys(): Promise<KeyRotationResult> {
    const keysToRotate = await this.getKeysNeedingRotation();
    const rotationResults: KeyRotationResult[] = [];

    for (const keyMetadata of keysToRotate) {
      try {
        // 新しいキー生成
        const newKey = await this.generateMasterKey();

        // 古いキーで暗号化されたデータの再暗号化
        await this.reencryptData(keyMetadata.keyId, newKey.keyId);

        // 古いキーを廃止
        await this.deprecateKey(keyMetadata.keyId);

        rotationResults.push({
          oldKeyId: keyMetadata.keyId,
          newKeyId: newKey.keyId,
          status: 'success'
        });

        logger.info('Key rotation completed', {
          oldKeyId: keyMetadata.keyId,
          newKeyId: newKey.keyId
        });

      } catch (error) {
        rotationResults.push({
          oldKeyId: keyMetadata.keyId,
          status: 'failed',
          error: error.message
        });

        logger.error('Key rotation failed', {
          keyId: keyMetadata.keyId,
          error
        });
      }
    }

    return {
      totalRotated: rotationResults.filter(r => r.status === 'success').length,
      totalFailed: rotationResults.filter(r => r.status === 'failed').length,
      details: rotationResults
    };
  }

  private async reencryptData(oldKeyId: string, newKeyId: string): Promise<void> {
    const batchSize = 1000;
    let offset = 0;

    while (true) {
      const encryptedRecords = await this.getEncryptedRecords(oldKeyId, batchSize, offset);
      if (encryptedRecords.length === 0) break;

      const reencryptedRecords = await Promise.all(
        encryptedRecords.map(record => this.reencryptRecord(record, oldKeyId, newKeyId))
      );

      await this.updateEncryptedRecords(reencryptedRecords);

      offset += batchSize;
    }
  }
}
```

## 5. ネットワークセキュリティ

### 5.1 TLS/SSL設定

```typescript
// Express.js セキュリティ設定
class SecurityConfig {
  static configureExpress(app: Express): void {
    // セキュリティヘッダー
    app.use(helmet({
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          styleSrc: ["'self'", "'unsafe-inline'"],
          scriptSrc: ["'self'"],
          connectSrc: ["'self'", "https://api.myjarvis.app"],
          imgSrc: ["'self'", "data:", "https:"],
          fontSrc: ["'self'"],
          objectSrc: ["'none'"],
          mediaSrc: ["'self'"],
          frameSrc: ["'none'"]
        }
      },
      hsts: {
        maxAge: 31536000, // 1年
        includeSubDomains: true,
        preload: true
      }
    }));

    // HTTPS強制リダイレクト
    app.use((req, res, next) => {
      if (req.header('x-forwarded-proto') !== 'https') {
        return res.redirect(`https://${req.header('host')}${req.url}`);
      }
      next();
    });

    // レート制限
    app.use('/api', rateLimit({
      windowMs: 15 * 60 * 1000, // 15分
      max: 100, // 最大100リクエスト
      message: 'Too many requests from this IP',
      standardHeaders: true,
      legacyHeaders: false
    }));

    // API固有のレート制限
    app.use('/api/auth', rateLimit({
      windowMs: 15 * 60 * 1000,
      max: 5, // 認証は厳しく制限
      skipSuccessfulRequests: true
    }));
  }

  // TLS証明書設定
  static getTLSConfig(): https.ServerOptions {
    return {
      key: fs.readFileSync(process.env.TLS_PRIVATE_KEY_PATH!),
      cert: fs.readFileSync(process.env.TLS_CERTIFICATE_PATH!),
      ca: fs.readFileSync(process.env.TLS_CA_PATH!),

      // TLS 1.3を優先
      minVersion: 'TLSv1.3',
      maxVersion: 'TLSv1.3',

      // 強力な暗号スイート
      ciphers: [
        'TLS_AES_256_GCM_SHA384',
        'TLS_CHACHA20_POLY1305_SHA256',
        'TLS_AES_128_GCM_SHA256'
      ].join(':'),

      // Perfect Forward Secrecy
      honorCipherOrder: true,

      // OCSP Stapling
      requestOCSP: true
    };
  }
}
```

### 5.2 API セキュリティ

```typescript
class APISecurityMiddleware {
  // JWT検証ミドルウェア
  static authenticateJWT = async (req: Request, res: Response, next: NextFunction) => {
    const authHeader = req.headers.authorization;
    const token = authHeader?.split(' ')[1];

    if (!token) {
      return res.status(401).json({ error: 'Access token required' });
    }

    try {
      const validation = await jwtManager.validateToken(token, 'myjarvis-client');

      if (!validation.valid) {
        return res.status(401).json({ error: validation.error });
      }

      // リクエストオブジェクトにユーザー情報を追加
      req.user = validation.payload;
      next();
    } catch (error) {
      logger.error('JWT validation error', { error });
      return res.status(401).json({ error: 'Invalid token' });
    }
  };

  // リクエスト検証
  static validateRequest = (schema: Joi.Schema) => {
    return (req: Request, res: Response, next: NextFunction) => {
      const { error } = schema.validate(req.body);

      if (error) {
        return res.status(400).json({
          error: 'VALIDATION_ERROR',
          details: error.details.map(d => ({
            field: d.path.join('.'),
            message: d.message
          }))
        });
      }

      next();
    };
  };

  // CORS設定
  static configureCORS(): cors.CorsOptions {
    return {
      origin: (origin, callback) => {
        const allowedOrigins = [
          'https://app.myjarvis.app',
          'https://admin.myjarvis.app'
        ];

        // 開発環境
        if (process.env.NODE_ENV === 'development') {
          allowedOrigins.push('http://localhost:3000', 'http://localhost:8080');
        }

        if (!origin || allowedOrigins.includes(origin)) {
          callback(null, true);
        } else {
          callback(new Error('Not allowed by CORS'));
        }
      },
      credentials: true,
      optionsSuccessStatus: 200,
      methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
      allowedHeaders: [
        'Origin',
        'X-Requested-With',
        'Content-Type',
        'Accept',
        'Authorization',
        'X-Device-ID',
        'X-Client-Version'
      ]
    };
  }

  // IPアドレス制限
  static ipWhitelist = (allowedIPs: string[]) => {
    return (req: Request, res: Response, next: NextFunction) => {
      const clientIP = req.ip || req.connection.remoteAddress;

      if (allowedIPs.includes(clientIP)) {
        next();
      } else {
        logger.warn('IP address not whitelisted', { ip: clientIP });
        res.status(403).json({ error: 'Access denied' });
      }
    };
  };
}
```

## 6. プライバシー保護実装

### 6.1 データ最小化

```typescript
class DataMinimizationService {
  // LLM送信前のデータマスキング
  async maskSensitiveDataForLLM(data: any): Promise<MaskedData> {
    const sensitivePatterns = [
      { pattern: /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g, type: 'email' },
      { pattern: /\b\d{3}-\d{2}-\d{4}\b/g, type: 'ssn' },
      { pattern: /\b\d{3}-\d{3}-\d{4}\b/g, type: 'phone' },
      { pattern: /\b\d{4}\s?\d{4}\s?\d{4}\s?\d{4}\b/g, type: 'credit_card' }
    ];

    const maskedData = JSON.parse(JSON.stringify(data));
    const maskingLog: MaskingLogEntry[] = [];

    const maskRecursively = (obj: any, path: string = ''): any => {
      if (typeof obj === 'string') {
        let masked = obj;

        for (const { pattern, type } of sensitivePatterns) {
          masked = masked.replace(pattern, (match) => {
            const maskingId = uuidv4();
            maskingLog.push({
              id: maskingId,
              type,
              originalValue: match,
              maskedValue: `[MASKED_${type.toUpperCase()}_${maskingId}]`,
              path
            });
            return `[MASKED_${type.toUpperCase()}_${maskingId}]`;
          });
        }

        return masked;
      } else if (Array.isArray(obj)) {
        return obj.map((item, index) =>
          maskRecursively(item, `${path}[${index}]`)
        );
      } else if (obj && typeof obj === 'object') {
        const masked: any = {};
        for (const [key, value] of Object.entries(obj)) {
          masked[key] = maskRecursively(value, path ? `${path}.${key}` : key);
        }
        return masked;
      }

      return obj;
    };

    const result = maskRecursively(maskedData);

    // マスキングログを暗号化保存（復元用）
    if (maskingLog.length > 0) {
      await this.storeMaskingLog(maskingLog);
    }

    return {
      data: result,
      maskingLogId: maskingLog.length > 0 ? maskingLog[0].id : null
    };
  }

  // データ保持期間管理
  async cleanupExpiredData(): Promise<CleanupResult> {
    const cleanupTasks = [
      // 90日以上古い同期ログ
      this.cleanupSyncLogs(90),

      // 30日以上古いセッションデータ
      this.cleanupExpiredSessions(30),

      // 1年以上古い監査ログ（法的保持期間後）
      this.cleanupAuditLogs(365),

      // 14日以上古いマスキングログ
      this.cleanupMaskingLogs(14)
    ];

    const results = await Promise.allSettled(cleanupTasks);

    return {
      completed: results.filter(r => r.status === 'fulfilled').length,
      failed: results.filter(r => r.status === 'rejected').length,
      details: results
    };
  }

  // 匿名化処理
  async anonymizeUserData(userId: string): Promise<AnonymizationResult> {
    const anonymizationId = uuidv4();

    // 個人識別情報の置き換え
    const replacements = {
      user_id: anonymizationId,
      email: `anonymous_${anonymizationId}@example.com`,
      name: `Anonymous User ${anonymizationId.slice(0, 8)}`
    };

    const affectedTables = [
      'sync_tasks',
      'schedules',
      'user_preferences',
      'notification_history'
    ];

    let totalRecords = 0;

    for (const table of affectedTables) {
      const result = await this.db.query(`
        UPDATE ${table}
        SET user_id = $1, updated_at = NOW()
        WHERE user_id = $2
      `, [anonymizationId, userId]);

      totalRecords += result.rowCount;
    }

    // 完全削除が必要なデータ
    await this.db.query('DELETE FROM user_sessions WHERE user_id = $1', [userId]);
    await this.db.query('DELETE FROM service_integrations WHERE user_id = $1', [userId]);

    return {
      anonymizationId,
      totalRecordsAnonymized: totalRecords,
      completedAt: new Date()
    };
  }
}
```

### 6.2 ユーザー制御機能

```typescript
class UserPrivacyControls {
  // データポータビリティ（データエクスポート）
  async exportUserData(userId: string): Promise<UserDataExport> {
    const userData = {
      profile: await this.getUserProfile(userId),
      tasks: await this.getUserTasks(userId),
      schedules: await this.getUserSchedules(userId),
      preferences: await this.getUserPreferences(userId),
      integrations: await this.getUserIntegrations(userId),
      // ローカルデータは含めない（デバイス内のみ）
    };

    // データを構造化JSON形式で出力
    const exportData = {
      exportId: uuidv4(),
      userId,
      exportedAt: new Date().toISOString(),
      format: 'application/json',
      data: userData
    };

    // セキュアなダウンロードリンク生成
    const downloadToken = await this.generateSecureDownloadToken(userId, exportData);

    return {
      exportId: exportData.exportId,
      downloadUrl: `https://api.myjarvis.app/privacy/download/${downloadToken}`,
      expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24時間
      estimatedSize: this.estimateDataSize(exportData)
    };
  }

  // 削除権（忘れられる権利）
  async deleteUserData(userId: string, deletionType: 'partial' | 'complete' = 'complete'): Promise<DeletionResult> {
    const deletionJob = {
      id: uuidv4(),
      userId,
      type: deletionType,
      initiatedAt: new Date(),
      status: 'in_progress'
    };

    // 削除ジョブを記録
    await this.recordDeletionJob(deletionJob);

    try {
      if (deletionType === 'complete') {
        // 完全削除: すべてのデータを削除
        await this.performCompleteDeletion(userId);
      } else {
        // 部分削除: 個人識別情報のみ匿名化
        await this.performPartialDeletion(userId);
      }

      deletionJob.status = 'completed';
      deletionJob.completedAt = new Date();

    } catch (error) {
      deletionJob.status = 'failed';
      deletionJob.error = error.message;
      throw error;

    } finally {
      await this.updateDeletionJob(deletionJob);
    }

    return deletionJob;
  }

  private async performCompleteDeletion(userId: string): Promise<void> {
    // 外部サービス連携の削除
    await this.revokeAllIntegrations(userId);

    // データベースからの完全削除
    const tablesToDelete = [
      'user_sessions',
      'service_integrations',
      'sync_tasks',
      'schedules',
      'user_preferences',
      'notification_history',
      'audit_logs',
      'users' // 最後にユーザー自体を削除
    ];

    for (const table of tablesToDelete) {
      await this.db.query(`DELETE FROM ${table} WHERE user_id = $1`, [userId]);
    }

    // キャッシュからの削除
    await this.clearUserCache(userId);

    // ファイルストレージからの削除（アップロードファイル等）
    await this.deleteUserFiles(userId);
  }

  // 同意管理
  async updateConsent(userId: string, consents: ConsentUpdate[]): Promise<ConsentResult> {
    const validConsents = [
      'data_processing',
      'marketing_communications',
      'analytics',
      'third_party_integrations',
      'ai_processing'
    ];

    const updates = consents.filter(c => validConsents.includes(c.type));

    for (const consent of updates) {
      await this.db.query(`
        INSERT INTO user_consents (user_id, consent_type, granted, granted_at, version)
        VALUES ($1, $2, $3, NOW(), $4)
        ON CONFLICT (user_id, consent_type)
        DO UPDATE SET
          granted = $3,
          granted_at = NOW(),
          version = $4
      `, [userId, consent.type, consent.granted, consent.version]);

      // 同意撤回時の処理
      if (!consent.granted) {
        await this.handleConsentWithdrawal(userId, consent.type);
      }
    }

    return {
      updatedConsents: updates.length,
      effectiveAt: new Date()
    };
  }

  private async handleConsentWithdrawal(userId: string, consentType: string): Promise<void> {
    switch (consentType) {
      case 'analytics':
        await this.disableAnalytics(userId);
        break;

      case 'ai_processing':
        await this.disableAIFeatures(userId);
        break;

      case 'third_party_integrations':
        await this.revokeAllIntegrations(userId);
        break;
    }
  }
}
```

## 7. セキュリティ監視・検知

### 7.1 異常検知システム

```typescript
class SecurityMonitoringService {
  private readonly anomalyThresholds = {
    loginAttempts: { max: 5, window: 15 * 60 * 1000 }, // 15分で5回
    apiCalls: { max: 1000, window: 60 * 60 * 1000 }, // 1時間で1000回
    dataAccess: { max: 100, window: 60 * 60 * 1000 }, // 1時間で100回
    locationChange: { distanceKm: 1000, timeHours: 1 } // 1時間で1000km以上の移動
  };

  async detectAnomalousActivity(userId: string, activity: SecurityEvent): Promise<AnomalyDetectionResult> {
    const checks = [
      this.checkLoginAnomalies(userId, activity),
      this.checkAPIUsageAnomalies(userId, activity),
      this.checkLocationAnomalies(userId, activity),
      this.checkDeviceAnomalies(userId, activity)
    ];

    const results = await Promise.all(checks);
    const anomalies = results.filter(r => r.isAnomaly);

    if (anomalies.length > 0) {
      await this.handleAnomalies(userId, anomalies);
    }

    return {
      hasAnomalies: anomalies.length > 0,
      anomalies,
      riskScore: this.calculateRiskScore(anomalies),
      actionsRequired: this.determineRequiredActions(anomalies)
    };
  }

  private async checkLoginAnomalies(userId: string, activity: SecurityEvent): Promise<AnomalyResult> {
    if (activity.type !== 'login_attempt') {
      return { isAnomaly: false, type: 'login' };
    }

    // 短時間での多数のログイン試行
    const recentAttempts = await this.getRecentLoginAttempts(
      userId,
      this.anomalyThresholds.loginAttempts.window
    );

    if (recentAttempts.length >= this.anomalyThresholds.loginAttempts.max) {
      return {
        isAnomaly: true,
        type: 'login',
        severity: 'high',
        description: 'Excessive login attempts detected',
        details: { attempts: recentAttempts.length }
      };
    }

    // 異常な時間帯でのログイン
    const hour = new Date(activity.timestamp).getHours();
    const userProfile = await this.getUserBehaviorProfile(userId);

    if (this.isUnusualLoginTime(hour, userProfile.typicalLoginHours)) {
      return {
        isAnomaly: true,
        type: 'login',
        severity: 'medium',
        description: 'Login at unusual time',
        details: { hour, typicalHours: userProfile.typicalLoginHours }
      };
    }

    return { isAnomaly: false, type: 'login' };
  }

  private async checkLocationAnomalies(userId: string, activity: SecurityEvent): Promise<AnomalyResult> {
    if (!activity.location) {
      return { isAnomaly: false, type: 'location' };
    }

    const lastKnownLocation = await this.getLastKnownLocation(userId);

    if (lastKnownLocation) {
      const distance = this.calculateDistance(lastKnownLocation, activity.location);
      const timeDiff = activity.timestamp - lastKnownLocation.timestamp;
      const hours = timeDiff / (1000 * 60 * 60);

      if (distance > this.anomalyThresholds.locationChange.distanceKm &&
          hours < this.anomalyThresholds.locationChange.timeHours) {
        return {
          isAnomaly: true,
          type: 'location',
          severity: 'high',
          description: 'Impossible travel detected',
          details: {
            distance,
            timeHours: hours,
            previousLocation: lastKnownLocation,
            currentLocation: activity.location
          }
        };
      }
    }

    return { isAnomaly: false, type: 'location' };
  }

  private async handleAnomalies(userId: string, anomalies: AnomalyResult[]): Promise<void> {
    // 高リスクの異常検知時の対応
    const highSeverityAnomalies = anomalies.filter(a => a.severity === 'high');

    if (highSeverityAnomalies.length > 0) {
      // ユーザーアカウントを一時ロック
      await this.temporaryLockAccount(userId, 'anomaly_detection');

      // セキュリティチームに即座にアラート
      await this.sendSecurityAlert({
        type: 'high_risk_anomaly',
        userId,
        anomalies: highSeverityAnomalies,
        timestamp: new Date()
      });

      // ユーザーにセキュリティ通知
      await this.sendUserSecurityNotification(userId, {
        type: 'account_locked',
        reason: 'suspicious_activity',
        verificationRequired: true
      });
    }

    // すべての異常をログに記録
    await this.logSecurityEvent({
      type: 'anomaly_detected',
      userId,
      anomalies,
      timestamp: new Date()
    });
  }
}
```

### 7.2 インシデント対応

```typescript
class IncidentResponseManager {
  async handleSecurityIncident(incident: SecurityIncident): Promise<IncidentResponse> {
    const response = {
      id: uuidv4(),
      type: incident.type,
      severity: this.assessIncidentSeverity(incident),
      status: 'active',
      createdAt: new Date(),
      actions: []
    };

    // インシデントタイプ別の対応
    switch (incident.type) {
      case 'data_breach':
        await this.handleDataBreach(incident, response);
        break;

      case 'unauthorized_access':
        await this.handleUnauthorizedAccess(incident, response);
        break;

      case 'malware_detected':
        await this.handleMalwareDetection(incident, response);
        break;

      case 'ddos_attack':
        await this.handleDDoSAttack(incident, response);
        break;
    }

    // インシデント記録
    await this.recordIncident(response);

    return response;
  }

  private async handleDataBreach(incident: SecurityIncident, response: IncidentResponse): Promise<void> {
    // 即座の対応
    response.actions.push({
      type: 'containment',
      description: 'Isolate affected systems',
      status: 'completed',
      timestamp: new Date()
    });

    // 影響を受けたユーザーの特定
    const affectedUsers = await this.identifyAffectedUsers(incident);

    // データ漏洩通知（法的要求に基づく）
    if (affectedUsers.length > 0) {
      await this.notifyDataBreach(affectedUsers, incident);

      response.actions.push({
        type: 'notification',
        description: `Notified ${affectedUsers.length} affected users`,
        status: 'completed',
        timestamp: new Date()
      });
    }

    // 外部への報告（72時間以内）
    await this.scheduleRegulatoryNotification(incident, response);

    // フォレンジック調査開始
    response.actions.push({
      type: 'investigation',
      description: 'Initiate forensic analysis',
      status: 'in_progress',
      timestamp: new Date()
    });
  }

  private async notifyDataBreach(affectedUsers: string[], incident: SecurityIncident): Promise<void> {
    for (const userId of affectedUsers) {
      // ユーザーへの個別通知
      await this.notificationService.send(userId, {
        type: 'data_breach_notification',
        subject: '重要：セキュリティインシデントについて',
        message: `
          いつもmyJarvisをご利用いただき、ありがとうございます。

          ${new Date().toLocaleDateString('ja-JP')}に発生したセキュリティインシデントについて
          お知らせいたします。

          【インシデント概要】
          - 発生日時: ${incident.timestamp}
          - 影響範囲: ${incident.description}
          - 流出可能性のあるデータ: ${incident.affectedDataTypes?.join(', ')}

          【お客様への影響】
          現在のところ、お客様の機微な個人情報（バイタル情報、詳細な行動ログ等）は
          ローカル保存されているため、今回のインシデントの影響を受けておりません。

          【対応状況】
          - インシデント発生後、直ちにシステムを隔離
          - 影響範囲の調査を実施中
          - 再発防止策を検討中

          【お客様にお願いしたいこと】
          - パスワードの変更をお願いいたします
          - 不審なアクティビティがないか確認をお願いします
          - 2段階認証の有効化をお願いいたします

          ご不明な点がございましたら、サポートチームまでお問い合わせください。

          myJarvis セキュリティチーム
        `,
        priority: 'high'
      });

      // パスワードリセットの強制
      await this.forcePasswordReset(userId);

      // セッションの無効化
      await this.revokeAllUserSessions(userId);
    }
  }
}
```

## 8. コンプライアンス

### 8.1 GDPR対応

```typescript
class GDPRComplianceManager {
  // 第28条: 処理者の義務
  async demonstrateCompliance(): Promise<ComplianceReport> {
    return {
      dataProcessingActivities: await this.getDataProcessingInventory(),
      technicalMeasures: await this.getTechnicalSafeguards(),
      organizationalMeasures: await this.getOrganizationalSafeguards(),
      dataSubjectRights: await this.getDataSubjectRightsImplementation(),
      lastAuditDate: await this.getLastComplianceAudit(),
      nextReviewDate: this.calculateNextReviewDate()
    };
  }

  // 第25条: データ保護バイデザイン
  private async getTechnicalSafeguards(): Promise<TechnicalSafeguard[]> {
    return [
      {
        measure: 'データ最小化',
        implementation: 'LLM送信前の個人情報マスキング',
        effectiveness: 'High',
        evidence: await this.getDataMinimizationLogs()
      },
      {
        measure: '目的制限',
        implementation: 'コンテキスト別データ分離',
        effectiveness: 'High',
        evidence: await this.getDataSegmentationReport()
      },
      {
        measure: '保存制限',
        implementation: '自動データ削除・匿名化',
        effectiveness: 'Medium',
        evidence: await this.getDataRetentionReport()
      },
      {
        measure: '完全性・機密性',
        implementation: 'エンドツーエンド暗号化',
        effectiveness: 'High',
        evidence: await this.getEncryptionReport()
      }
    ];
  }

  // 第32条: 処理の安全性
  async assessSecurityMeasures(): Promise<SecurityAssessment> {
    const measures = [
      await this.assessEncryptionImplementation(),
      await this.assessAccessControls(),
      await this.assessBackupAndRecovery(),
      await this.assessIncidentResponse()
    ];

    return {
      overallRating: this.calculateSecurityRating(measures),
      measures,
      recommendations: await this.generateSecurityRecommendations(measures),
      assessmentDate: new Date()
    };
  }

  // 第35条: データ保護影響評価 (DPIA)
  async conductDPIA(processingActivity: ProcessingActivity): Promise<DPIA> {
    const dpia = {
      id: uuidv4(),
      processingActivity,
      conductedBy: 'Data Protection Officer',
      date: new Date(),

      // 処理の説明
      processingDescription: {
        purpose: processingActivity.purpose,
        dataTypes: processingActivity.dataTypes,
        dataSubjects: processingActivity.dataSubjects,
        recipients: processingActivity.recipients,
        retentionPeriod: processingActivity.retentionPeriod
      },

      // 必要性・比例性評価
      necessityAssessment: await this.assessNecessity(processingActivity),

      // リスク評価
      riskAssessment: await this.assessPrivacyRisks(processingActivity),

      // 対策
      mitigationMeasures: await this.identifyMitigationMeasures(processingActivity),

      // 結論
      conclusion: 'Processing may proceed with specified safeguards'
    };

    await this.storeDPIA(dpia);
    return dpia;
  }
}
```

### 8.2 監査・証明

```typescript
class AuditManager {
  // SOC 2 Type II対応
  async generateSOC2Report(reportPeriod: DateRange): Promise<SOC2Report> {
    const trustServicesCriteria = [
      await this.auditSecurityCriteria(reportPeriod),
      await this.auditAvailabilityCriteria(reportPeriod),
      await this.auditProcessingIntegrityCriteria(reportPeriod),
      await this.auditConfidentialityCriteria(reportPeriod),
      await this.auditPrivacyCriteria(reportPeriod)
    ];

    return {
      reportPeriod,
      serviceOrganization: 'myJarvis Inc.',
      auditor: 'Independent Third-Party Auditor',

      // システム記述
      systemDescription: await this.generateSystemDescription(),

      // 統制環境
      controlEnvironment: await this.assessControlEnvironment(),

      // 各基準の評価
      trustServicesCriteria,

      // 例外事項
      exceptions: await this.identifyControlExceptions(reportPeriod),

      // 改善勧告
      recommendations: await this.generateImprovementRecommendations()
    };
  }

  private async auditSecurityCriteria(period: DateRange): Promise<CriteriaAuditResult> {
    const controls = [
      // CC6.1: 論理的・物理的アクセス制御
      await this.auditAccessControls(period),

      // CC6.2: 認証前の通信保護
      await this.auditCommunicationSecurity(period),

      // CC6.3: 認証後のデータ通信保護
      await this.auditDataInTransit(period),

      // CC6.6: 脆弱性管理
      await this.auditVulnerabilityManagement(period),

      // CC6.7: データ分類・保護
      await this.auditDataProtection(period)
    ];

    return {
      criteria: 'Security',
      overallRating: this.calculateCriteriaRating(controls),
      controls,
      testingProcedures: await this.getTestingProcedures('security'),
      exceptions: controls.filter(c => c.rating === 'exception')
    };
  }

  // 継続的監査システム
  async setupContinuousAuditing(): Promise<void> {
    // 自動化された統制テスト
    const auditJobs = [
      // 日次: アクセス制御テスト
      this.scheduleJob('daily', this.testAccessControls),

      // 週次: データ暗号化検証
      this.scheduleJob('weekly', this.testEncryptionImplementation),

      // 月次: 脆弱性スキャン
      this.scheduleJob('monthly', this.performVulnerabilityScan),

      // 四半期: ペネトレーションテスト
      this.scheduleJob('quarterly', this.performPenetrationTesting)
    ];

    await Promise.all(auditJobs);
  }

  private async testAccessControls(): Promise<ControlTestResult> {
    const tests = [
      // 未承認アクセスの試行
      await this.testUnauthorizedAccess(),

      // 権限昇格の試行
      await this.testPrivilegeEscalation(),

      // セッション管理の検証
      await this.testSessionManagement(),

      // MFA回避の試行
      await this.testMFABypass()
    ];

    return {
      controlName: 'Access Controls',
      testDate: new Date(),
      overallResult: tests.every(t => t.passed) ? 'PASS' : 'FAIL',
      details: tests,
      recommendations: tests.filter(t => !t.passed).map(t => t.recommendation)
    };
  }
}
```

## 9. インシデント対応計画

### 9.1 対応体制

```typescript
interface IncidentResponseTeam {
  incidentCommander: string;
  securityAnalyst: string;
  systemAdministrator: string;
  legalCounsel: string;
  publicRelations: string;
  dataProtectionOfficer: string;
}

class IncidentResponsePlan {
  private readonly responseTeam: IncidentResponseTeam = {
    incidentCommander: 'security-team@myjarvis.com',
    securityAnalyst: 'analyst@myjarvis.com',
    systemAdministrator: 'sysadmin@myjarvis.com',
    legalCounsel: 'legal@myjarvis.com',
    publicRelations: 'pr@myjarvis.com',
    dataProtectionOfficer: 'dpo@myjarvis.com'
  };

  async executeResponsePlan(incident: SecurityIncident): Promise<ResponseExecution> {
    const phases = [
      await this.preparation(incident),
      await this.identification(incident),
      await this.containment(incident),
      await this.eradication(incident),
      await this.recovery(incident),
      await this.postIncidentActivity(incident)
    ];

    return {
      incidentId: incident.id,
      phases,
      duration: this.calculateTotalDuration(phases),
      outcome: this.assessOutcome(phases)
    };
  }

  private async identification(incident: SecurityIncident): Promise<ResponsePhase> {
    const startTime = Date.now();

    // インシデントの検証と分類
    const classification = await this.classifyIncident(incident);

    // エスカレーション判定
    const escalationLevel = this.determineEscalation(classification);

    // 対応チームの召集
    await this.assembleResponseTeam(escalationLevel);

    return {
      phase: 'identification',
      duration: Date.now() - startTime,
      actions: [
        'Incident verified and classified',
        'Response team assembled',
        `Escalation level: ${escalationLevel}`
      ],
      status: 'completed'
    };
  }

  private async containment(incident: SecurityIncident): Promise<ResponsePhase> {
    const startTime = Date.now();
    const actions = [];

    // 短期封じ込め
    if (this.requiresImmediateContainment(incident)) {
      await this.performImmediateContainment(incident);
      actions.push('Immediate containment measures applied');
    }

    // 長期封じ込め
    const containmentStrategy = await this.developContainmentStrategy(incident);
    await this.implementContainmentStrategy(containmentStrategy);
    actions.push('Long-term containment strategy implemented');

    // フォレンジック証拠の保全
    if (this.requiresForensics(incident)) {
      await this.preserveForensicEvidence(incident);
      actions.push('Forensic evidence preserved');
    }

    return {
      phase: 'containment',
      duration: Date.now() - startTime,
      actions,
      status: 'completed'
    };
  }
}
```

### 9.2 通知・報告手順

```typescript
class NotificationManager {
  private readonly notificationThresholds = {
    // 高リスクインシデント: 1時間以内
    high: 60 * 60 * 1000,
    // 中リスクインシデント: 4時間以内
    medium: 4 * 60 * 60 * 1000,
    // 低リスクインシデント: 24時間以内
    low: 24 * 60 * 60 * 1000
  };

  async executeNotificationProcedure(incident: SecurityIncident): Promise<NotificationResult> {
    const notifications = [];

    // 内部通知
    notifications.push(await this.notifyInternalTeams(incident));

    // 法的通知（必要な場合）
    if (this.requiresRegulatoryNotification(incident)) {
      notifications.push(await this.notifyRegulators(incident));
    }

    // ユーザー通知（必要な場合）
    if (this.requiresUserNotification(incident)) {
      notifications.push(await this.notifyAffectedUsers(incident));
    }

    // パートナー通知（必要な場合）
    if (this.requiresPartnerNotification(incident)) {
      notifications.push(await this.notifyBusinessPartners(incident));
    }

    return {
      totalNotifications: notifications.length,
      successful: notifications.filter(n => n.status === 'success').length,
      failed: notifications.filter(n => n.status === 'failed').length,
      details: notifications
    };
  }

  private async notifyRegulators(incident: SecurityIncident): Promise<NotificationDetail> {
    // GDPR: データ侵害は72時間以内に監督当局に報告
    if (incident.type === 'data_breach' && this.affectsEUResidents(incident)) {
      const notification = {
        authority: 'Personal Data Protection Commission',
        incident: {
          id: incident.id,
          type: incident.type,
          description: incident.description,
          affectedDataTypes: incident.affectedDataTypes,
          estimatedAffectedRecords: incident.estimatedAffectedRecords,
          breachDate: incident.timestamp,
          discoveryDate: incident.discoveredAt,
          containmentMeasures: incident.containmentMeasures,
          risksToDataSubjects: this.assessRisksToDataSubjects(incident)
        },
        submittedBy: 'Data Protection Officer',
        submissionDate: new Date()
      };

      try {
        await this.submitBreachNotification(notification);
        return {
          recipient: 'Data Protection Authority',
          status: 'success',
          timestamp: new Date()
        };
      } catch (error) {
        return {
          recipient: 'Data Protection Authority',
          status: 'failed',
          error: error.message,
          timestamp: new Date()
        };
      }
    }

    return {
      recipient: 'Regulators',
      status: 'skipped',
      reason: 'No regulatory notification required',
      timestamp: new Date()
    };
  }
}
```

## 10. 実装考慮事項

### 10.1 開発フェーズ

**Phase 1 (3ヶ月): 基盤セキュリティ**
- 認証・認可システム実装
- データ暗号化基盤
- 基本的なアクセス制御

**Phase 2 (2ヶ月): 高度なセキュリティ**
- 多要素認証実装
- 異常検知システム
- インシデント対応自動化

**Phase 3 (2ヶ月): コンプライアンス対応**
- GDPR・個人情報保護法対応
- 監査システム構築
- プライバシー制御機能

**Phase 4 (継続): 運用・改善**
- 脅威インテリジェンス統合
- AI/ML活用した高度な検知
- セキュリティ文化の醸成

### 10.2 テスト戦略

```typescript
// セキュリティテスト例
describe('Authentication Security', () => {
  describe('JWT Token Validation', () => {
    it('should reject tampered tokens', async () => {
      const validToken = await jwtManager.generateToken(testUser);
      const tamperedToken = validToken.slice(0, -10) + 'tampered123';

      const result = await jwtManager.validateToken(tamperedToken, 'myjarvis-client');

      expect(result.valid).toBe(false);
      expect(result.error).toBe('INVALID_SIGNATURE');
    });

    it('should reject expired tokens', async () => {
      const expiredToken = await jwtManager.generateToken(testUser, { expiresIn: -1 });

      const result = await jwtManager.validateToken(expiredToken, 'myjarvis-client');

      expect(result.valid).toBe(false);
      expect(result.error).toBe('TOKEN_EXPIRED');
    });

    it('should handle token blacklisting', async () => {
      const token = await jwtManager.generateToken(testUser);
      await jwtManager.revokeToken(token.jti);

      const result = await jwtManager.validateToken(token.accessToken, 'myjarvis-client');

      expect(result.valid).toBe(false);
      expect(result.error).toBe('TOKEN_REVOKED');
    });
  });

  describe('Encryption Implementation', () => {
    it('should encrypt and decrypt data correctly', async () => {
      const sensitiveData = 'user@example.com';
      const masterKey = Buffer.from('test-key-32-bytes-long-for-aes256', 'utf8');

      const encrypted = await encryptionManager.encryptField(
        sensitiveData,
        masterKey,
        'email'
      );

      const decrypted = await encryptionManager.decryptField(encrypted, masterKey);

      expect(decrypted).toBe(sensitiveData);
      expect(encrypted.encrypted).not.toBe(sensitiveData);
    });

    it('should fail decryption with wrong key', async () => {
      const sensitiveData = 'user@example.com';
      const correctKey = Buffer.from('correct-key-32-bytes-long-for-test', 'utf8');
      const wrongKey = Buffer.from('wrong-key-32-bytes-long-for-testing', 'utf8');

      const encrypted = await encryptionManager.encryptField(
        sensitiveData,
        correctKey,
        'email'
      );

      await expect(
        encryptionManager.decryptField(encrypted, wrongKey)
      ).rejects.toThrow();
    });
  });
});
```

## 11. 関連文書

- [01-システムアーキテクチャ設計](/docs/design/01-システムアーキテクチャ設計.md)
- [02-API設計](/docs/design/02-API設計.md)
- [03-データベーススキーマ設計](/docs/design/03-データベーススキーマ設計.md)
- [05-外部サービス統合設計](/docs/design/05-外部サービス統合設計.md)
- [ADR-005: データストレージ・プライバシー戦略](/docs/adr/ADR-005-データストレージ・プライバシー戦略.md)

---

*この設計書は、myJarvis システムにおける包括的なセキュリティ・プライバシー保護設計を提供し、ユーザーの信頼を獲得しながら法的要求事項に準拠したシステムの実現を支援します。*