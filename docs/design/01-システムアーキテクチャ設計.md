# システムアーキテクチャ設計書

**バージョン:** 1.0
**日付:** 2025-09-25
**ステータス:** 初版
**作成者:** 開発チーム

## 1. 概要と目的

### 1.1 概要
本設計書は、myJarvis個人AIアシスタントの全体システムアーキテクチャを定義します。マルチプラットフォーム（iOS + Web）対応、外部サービス統合、AI/ML機能、リアルタイム同期を統合したアーキテクチャを提示します。

### 1.2 目的
- システム全体の構造と各コンポーネント間の関係を明確化
- 開発チーム間での共通理解の促進
- 技術決定の背景とトレードオフの記録
- システム拡張・保守時の指針提供

### 1.3 対象読者
- アーキテクト、リードエンジニア
- iOS・Web・バックエンド開発者
- プロダクトマネージャー
- QAエンジニア

## 2. システム要求事項

### 2.1 機能要求事項
- **マルチプラットフォーム対応**: iOS・Web間でのシームレスなデータ同期
- **外部サービス統合**: Google Calendar、Gmail、Slack等との連携
- **AI/ML機能**: タスク分解（LLM）・スケジューリング最適化（ローカルML）
- **リアルタイム同期**: デバイス間での即座なデータ反映
- **通知システム**: 適切なタイミングでのパーソナライズ通知
- **プライバシー保護**: 機微データのローカル保持・暗号化

### 2.2 非機能要求事項
- **可用性**: 99.5%以上のアップタイム
- **レスポンス性**: UI操作の応答時間 < 200ms
- **同期性能**: デバイス間同期遅延 < 500ms
- **セキュリティ**: エンドツーエンド暗号化、多要素認証
- **スケーラビリティ**: 10万ユーザーまでの対応
- **保守性**: モジュラー設計による容易な機能追加・修正

## 3. アーキテクチャ概要

### 3.1 ハイレベルアーキテクチャ

```
┌─────────────────────────────────────────────────────────────────┐
│                    myJarvis システムアーキテクチャ                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────┐    ┌─────────────────────────┐     │
│  │       iOS Client        │    │       Web Client        │     │
│  │                         │    │                         │     │
│  │ ┌─────────────────────┐ │    │ ┌─────────────────────┐ │     │
│  │ │     SwiftUI         │ │    │ │      React          │ │     │
│  │ │    (Native UI)      │ │    │ │    (Native UI)      │ │     │
│  │ └─────────────────────┘ │    │ └─────────────────────┘ │     │
│  │ ┌─────────────────────┐ │    │ ┌─────────────────────┐ │     │
│  │ │  KMP Shared Core    │ │    │ │  KMP Shared Core    │ │     │
│  │ │ • Business Logic    │ │    │ │ • Business Logic    │ │     │
│  │ │ • Local ML Models   │ │    │ │ • Local ML Models   │ │     │
│  │ │ • WebSocket Client  │ │    │ │ • WebSocket Client  │ │     │
│  │ │ • Local Storage     │ │    │ │ • Local Storage     │ │     │
│  │ └─────────────────────┘ │    │ └─────────────────────┘ │     │
│  └─────────────────────────┘    └─────────────────────────┘     │
│               │                             │                    │
│               └─────────────┬───────────────┘                    │
│                             │                                    │
│            ┌────────────────▼────────────────┐                   │
│            │        WebSocket Layer          │                   │
│            │     (Bidirectional Sync)        │                   │
│            └────────────────┬────────────────┘                   │
│                             │                                    │
│  ┌─────────────────────────▼─────────────────────────┐          │
│  │              myJarvis BFF (Node.js)               │          │
│  │                                                   │          │
│  │ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐  │          │
│  │ │  WebSocket  │ │    API      │ │    Auth     │  │          │
│  │ │   Manager   │ │  Gateway    │ │  Manager    │  │          │
│  │ └─────────────┘ └─────────────┘ └─────────────┘  │          │
│  │ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐  │          │
│  │ │    LLM      │ │  External   │ │    Event    │  │          │
│  │ │ Processor   │ │ Integrator  │ │  Processor  │  │          │
│  │ └─────────────┘ └─────────────┘ └─────────────┘  │          │
│  └───────────────┬───────────────┬───────────────────┘          │
│                  │               │                              │
│  ┌───────────────▼───┐    ┌──────▼──────┐                      │
│  │   Redis Cluster   │    │ PostgreSQL  │                      │
│  │  (Pub/Sub, Cache) │    │ (Main DB)   │                      │
│  └───────────────────┘    └─────────────┘                      │
│                                   │                              │
│  ┌───────────────────────────────▼───────────────────────────┐  │
│  │              External Services                            │  │
│  │                                                           │  │
│  │ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │  │
│  │ │   Google    │ │    Gmail    │ │    Slack    │   ...    │  │
│  │ │  Calendar   │ │             │ │             │          │  │
│  │ └─────────────┘ └─────────────┘ └─────────────┘          │  │
│  │                                                           │  │
│  │ ┌─────────────┐ ┌─────────────┐                          │  │
│  │ │  OpenAI     │ │   Google    │                          │  │
│  │ │    API      │ │  Gemini     │                          │  │
│  │ └─────────────┘ └─────────────┘                          │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 アーキテクチャ原則

1. **共有コア + ネイティブUI**: ビジネスロジックをKotlin Multiplatformで共通化、UIは各プラットフォームでネイティブ実装
2. **BFFパターン**: Backend for Frontendによる外部サービス統合の集約と安全な管理
3. **ハイブリッドAI/ML**: LLMはクラウド、スケジューリング最適化はローカル実行
4. **リアルタイム同期**: WebSocketによる即座のデータ同期
5. **階層化データストレージ**: 機密性に応じたデータ配置（ローカル/クラウド）
6. **プライバシーバイデザイン**: 機微データの外部送信最小化

## 4. コンポーネント設計

### 4.1 クライアントサイドアーキテクチャ

#### 4.1.1 KMP Shared Core
**責務**: プラットフォーム間で共通のビジネスロジック

**主要モジュール**:
```kotlin
// コアドメインモデル
interface TaskManager {
    suspend fun createTask(task: Task): Result<TaskId>
    suspend fun updateTask(taskId: TaskId, updates: TaskUpdate): Result<Unit>
    suspend fun deleteTask(taskId: TaskId): Result<Unit>
}

// スケジューリングエンジン（ローカルML）
interface SchedulingEngine {
    suspend fun optimizeSchedule(tasks: List<Task>, constraints: UserConstraints): Schedule
    suspend fun updateUserFeedback(scheduleId: ScheduleId, satisfaction: SatisfactionScore)
}

// データ同期
interface SyncManager {
    val connectionState: StateFlow<ConnectionState>
    suspend fun synchronize(): Result<SyncResult>
    fun subscribeToUpdates(): Flow<DataUpdate>
}

// ローカルストレージ
interface LocalStorage {
    suspend fun storeSecurely(key: String, data: ByteArray)
    suspend fun retrieveSecurely(key: String): ByteArray?
    suspend fun deleteSecurely(key: String)
}
```

#### 4.1.2 プラットフォーム固有実装

**iOS (SwiftUI)**:
```swift
// ViewModel層
@MainActor
class TaskListViewModel: ObservableObject {
    @Published var tasks: [TaskViewModel] = []
    @Published var isLoading = false

    private let taskManager: TaskManager
    private let syncManager: SyncManager

    func loadTasks() async {
        // KMPのTaskManagerを呼び出し
    }
}

// View層
struct TaskListView: View {
    @StateObject private var viewModel = TaskListViewModel()

    var body: some View {
        NavigationView {
            List(viewModel.tasks) { task in
                TaskRowView(task: task)
            }
            .task { await viewModel.loadTasks() }
        }
    }
}
```

**Web (React + TypeScript)**:
```typescript
// カスタムフック
const useTaskManager = () => {
  const [tasks, setTasks] = useState<Task[]>([]);
  const [isLoading, setIsLoading] = useState(false);

  // KMPモジュールの呼び出し（WASM経由）
  const taskManager = useMemo(() => createTaskManager(), []);

  const loadTasks = useCallback(async () => {
    setIsLoading(true);
    try {
      const result = await taskManager.getAllTasks();
      setTasks(result);
    } finally {
      setIsLoading(false);
    }
  }, [taskManager]);

  return { tasks, isLoading, loadTasks };
};

// コンポーネント
const TaskList: React.FC = () => {
  const { tasks, isLoading, loadTasks } = useTaskManager();

  useEffect(() => {
    loadTasks();
  }, [loadTasks]);

  return (
    <div className="task-list">
      {isLoading ? <Spinner /> :
       tasks.map(task => <TaskItem key={task.id} task={task} />)}
    </div>
  );
};
```

### 4.2 サーバーサイドアーキテクチャ

#### 4.2.1 BFF (Backend for Frontend)

**技術スタック**: Node.js + TypeScript + Express/Fastify

**主要コンポーネント**:
```typescript
// API Gateway
class ApiGateway {
  async handleRequest(req: Request): Promise<Response> {
    const authResult = await this.authManager.authenticate(req);
    if (!authResult.success) return unauthorized();

    return await this.routeRequest(req, authResult.user);
  }
}

// WebSocket Manager
class WebSocketManager {
  private connections = new Map<UserId, WebSocket[]>();

  async broadcastToUser(userId: UserId, message: MessagePayload): Promise<void> {
    const userConnections = this.connections.get(userId) || [];
    await Promise.all(
      userConnections.map(ws => this.sendMessage(ws, message))
    );
  }
}

// External Service Integrator
class ExternalServiceIntegrator {
  async syncGoogleCalendar(userId: UserId): Promise<CalendarEvent[]> {
    const tokens = await this.authManager.getTokens(userId, 'google');
    const events = await this.googleApi.getEvents(tokens);
    return events.map(this.normalizeEvent);
  }
}

// LLM Processor
class LLMProcessor {
  async decomposeTask(taskDescription: string, context: TaskContext): Promise<TaskStructure> {
    const prompt = this.promptTemplate.generate(taskDescription, context);
    const response = await this.llmApi.complete(prompt);
    return this.parseTaskStructure(response);
  }
}
```

#### 4.2.2 データベース設計

**主要テーブル**:
```sql
-- ユーザー管理
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR(255) UNIQUE NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- 外部サービス認証情報
CREATE TABLE service_auth (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id),
  service_type VARCHAR(50) NOT NULL,
  encrypted_tokens TEXT NOT NULL,
  expires_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW()
);

-- 同期可能なタスク情報（機微でない基本情報のみ）
CREATE TABLE sync_tasks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id),
  title VARCHAR(255) NOT NULL,
  due_date TIMESTAMP,
  status VARCHAR(50) DEFAULT 'active',
  version INTEGER DEFAULT 1,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- 外部サービス同期状態
CREATE TABLE sync_status (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id),
  service_type VARCHAR(50) NOT NULL,
  last_sync_at TIMESTAMP,
  sync_token TEXT,
  status VARCHAR(50) DEFAULT 'active'
);
```

## 5. データフローとシーケンス

### 5.1 タスク作成フロー

```sequence
User -> iOS/Web UI: タスク作成
iOS/Web UI -> KMP Core: TaskManager.createTask()
KMP Core -> Local Storage: セキュアに保存
KMP Core -> WebSocket: サーバーに同期要求
WebSocket -> BFF: TaskSyncRequest
BFF -> PostgreSQL: 基本情報のみ保存
BFF -> Redis Pub/Sub: 他クライアントに通知
Redis Pub/Sub -> WebSocket: ブロードキャスト
WebSocket -> 他のデバイス: リアルタイム更新
```

### 5.2 LLMタスク分解フロー

```sequence
User -> UI: 複雑なタスク入力
UI -> KMP Core: TaskDecomposer.decompose()
KMP Core -> WebSocket: LLM処理要求（個人情報マスク済み）
WebSocket -> BFF: LLMProcessRequest
BFF -> LLM Processor: プロンプト生成・API呼び出し
LLM Processor -> OpenAI/Gemini: API リクエスト
OpenAI/Gemini -> LLM Processor: 分解されたタスク構造
LLM Processor -> BFF: レスポンス処理
BFF -> WebSocket: 分解結果送信
WebSocket -> KMP Core: タスク構造受信
KMP Core -> UI: 分解されたタスクを表示
```

### 5.3 ローカルMLスケジューリング最適化フロー

```sequence
KMP Core -> Local ML Engine: 最適化要求
Local ML Engine -> Local Storage: ユーザー行動データ読み込み
Local ML Engine -> Feature Extractor: 特徴量生成
Feature Extractor -> TensorFlow Lite: モデル推論
TensorFlow Lite -> Feature Extractor: 最適化結果
Feature Extractor -> Local ML Engine: スケジュール候補
Local ML Engine -> KMP Core: 最適化されたスケジュール
KMP Core -> UI: スケジュール表示
User -> UI: フィードバック入力
UI -> Local ML Engine: 満足度学習データ
Local ML Engine -> TensorFlow Lite: モデル更新
```

## 6. セキュリティアーキテクチャ

### 6.1 認証・認可フロー

```
[Client] -> [BFF] -> [Auth Provider] -> [JWT Token] -> [Secure Storage]
    |         |           |               |              |
    |    HTTPS/WSS    OAuth 2.0        RS256         Keychain/
    |                                                 Web Crypto
    |
[Device Certificate] -> [Hardware Security Module]
```

### 6.2 データ暗号化層

**転送時暗号化**:
- WebSocket: WSS (TLS 1.3)
- REST API: HTTPS (TLS 1.3)
- Perfect Forward Secrecy

**保存時暗号化**:
```typescript
// クライアント側
interface SecureStorage {
  // ハードウェアベース暗号化
  encryptWithDeviceKey(data: ByteArray): EncryptedData;
  decryptWithDeviceKey(encrypted: EncryptedData): ByteArray;
}

// サーバー側
interface DatabaseEncryption {
  // KMS管理キーによる暗号化
  encryptColumn(column: string, data: any): EncryptedColumn;
  decryptColumn(encrypted: EncryptedColumn): any;
}
```

## 7. パフォーマンス設計

### 7.1 レスポンス時間要件

| 操作 | 目標レスポンス時間 | 最大許容時間 |
|------|-------------------|-------------|
| UI操作反応 | < 100ms | < 200ms |
| ローカルデータ読み込み | < 50ms | < 100ms |
| サーバー同期 | < 300ms | < 500ms |
| デバイス間同期 | < 300ms | < 500ms |
| LLMタスク分解 | < 2s | < 5s |
| ローカルML推論 | < 100ms | < 200ms |

### 7.2 キャッシング戦略

```typescript
// 多層キャッシング
interface CacheStrategy {
  // L1: メモリキャッシュ (最頻利用データ)
  memoryCache: LRUCache<string, any>;

  // L2: ローカルストレージ (中頻度データ)
  localCache: PersistentCache;

  // L3: Redis (サーバーサイド共有)
  redisCache: RedisCache;
}
```

### 7.3 負荷分散・スケーリング

```
[Load Balancer (ALB)]
         |
    ┌────┴────┐
    │         │
[BFF Node 1] [BFF Node 2] ... [BFF Node N]
    │         │                   │
    └─────────┼───────────────────┘
              │
    [Redis Cluster (Pub/Sub)]
              │
    [PostgreSQL (Read Replicas)]
```

## 8. 監視・運用設計

### 8.1 メトリクス収集

```typescript
interface SystemMetrics {
  // アプリケーションメトリクス
  responseTime: Histogram;
  errorRate: Counter;
  activeConnections: Gauge;

  // ビジネスメトリクス
  taskCompletionRate: Gauge;
  userSatisfactionScore: Histogram;
  syncSuccessRate: Gauge;
}
```

### 8.2 ログ設計

```json
{
  "timestamp": "2025-09-25T10:00:00Z",
  "level": "INFO",
  "service": "myjarvis-bff",
  "userId": "masked",
  "operation": "task_sync",
  "duration": 150,
  "success": true,
  "metadata": {
    "deviceType": "ios",
    "version": "1.0.0"
  }
}
```

## 9. 災害復旧・バックアップ

### 9.1 データバックアップ戦略

- **ローカルデータ**: ユーザー自身のデバイスバックアップ（iCloud、Google Drive等）
- **同期データ**: PostgreSQL自動バックアップ（日次・週次）
- **設定データ**: Redis持続化ストレージ

### 9.2 障害対応

```
Primary System Failure
         |
    Failover to DR
         |
    Data Consistency Check
         |
    Service Restoration
         |
    User Notification
```

## 10. 実装考慮事項

### 10.1 開発フェーズ

**Phase 1**: 基本機能（3ヶ月）
- KMP共有コア実装
- 基本的なタスク管理
- シンプルなBFF
- 基本認証

**Phase 2**: AI/ML統合（2ヶ月）
- LLMタスク分解
- ローカルML実装
- 外部サービス連携

**Phase 3**: リアルタイム同期（2ヶ月）
- WebSocket実装
- リアルタイム同期
- 通知システム

**Phase 4**: 最適化・運用（継続）
- パフォーマンス最適化
- セキュリティ強化
- 運用監視

### 10.2 テスト戦略

- **単体テスト**: KMPコア・BFFの各モジュール
- **統合テスト**: API・WebSocket通信
- **E2Eテスト**: マルチデバイス同期シナリオ
- **パフォーマンステスト**: 負荷・レスポンス時間
- **セキュリティテスト**: 脆弱性診断・ペネトレーション

## 11. 今後の拡張性

### 11.1 新機能追加パターン

```typescript
// プラグインアーキテクチャ
interface FeaturePlugin {
  name: string;
  version: string;
  initialize(): Promise<void>;
  getUIComponents(): UIComponentMap;
  getAPIEndpoints(): APIEndpointMap;
}
```

### 11.2 外部サービス追加

```typescript
// 新サービス追加のインターフェース
interface ExternalServiceAdapter {
  serviceName: string;
  authenticate(credentials: AuthCredentials): Promise<AuthResult>;
  syncData(syncRequest: SyncRequest): Promise<SyncResult>;
  normalizeData(rawData: any): NormalizedData;
}
```

## 12. 関連文書

- [ADR-001: マルチプラットフォーム戦略](/docs/adr/ADR-001-マルチプラットフォーム戦略.md)
- [ADR-002: 外部サービス統合戦略](/docs/adr/ADR-002-外部サービス統合戦略.md)
- [ADR-003: AI/MLパイプライン設計](/docs/adr/ADR-003-AI-MLパイプライン設計.md)
- [ADR-004: 通知システム設計](/docs/adr/ADR-004-通知システム設計.md)
- [ADR-005: データストレージ・プライバシー戦略](/docs/adr/ADR-005-データストレージ・プライバシー戦略.md)
- [ADR-006: リアルタイム同期戦略](/docs/adr/ADR-006-リアルタイム同期戦略.md)

---

*この設計書は、ADRに基づいてmyJarvisシステムの包括的なアーキテクチャを定義し、実装チームが効率的に開発を進められるよう詳細な技術仕様を提供します。*