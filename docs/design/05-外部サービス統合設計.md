# 外部サービス統合設計書

**バージョン:** 1.0
**日付:** 2025-09-25
**ステータス:** 初版
**作成者:** 開発チーム

## 1. 概要と目的

### 1.1 概要
本設計書は、myJarvisシステムが Google Calendar、Gmail、Slack等の外部サービスと統合するための詳細設計を定義します。BFF（Backend for Frontend）パターンを採用し、セキュア且つ効率的な外部サービス連携を実現します。

### 1.2 設計目標
- **セキュリティファースト**: 認証情報の安全な管理と暗号化
- **拡張性**: 新しい外部サービス追加の容易さ
- **信頼性**: エラーハンドリングと再試行機能
- **効率性**: レート制限とキャッシング戦略
- **監視可能性**: ログ・メトリクス・アラートの充実

### 1.3 対象読者
- バックエンド開発者
- インフラエンジニア
- セキュリティエンジニア
- システム運用担当者

## 2. 統合対象サービス

### 2.1 サポート予定サービス

| サービス | 機能 | 優先度 | 実装フェーズ |
|---------|------|--------|-------------|
| **Google Calendar** | カレンダー同期、イベント作成 | High | Phase 1 |
| **Gmail** | メール内容解析、タスク抽出 | High | Phase 1 |
| **Google Tasks** | タスク同期 | Medium | Phase 2 |
| **Slack** | チャネル・DM監視、通知送信 | Medium | Phase 2 |
| **Microsoft 365** | Outlook Calendar・Mail | Medium | Phase 3 |
| **GitHub** | Issue・PR管理 | Low | Phase 3 |
| **Zoom** | 会議情報取得 | Low | Phase 4 |

### 2.2 統合レベル定義

**Level 1 - 読み取り専用**:
- データの取得・同期のみ
- 例: Gmail メール読み取り、Calendar イベント取得

**Level 2 - 双方向同期**:
- データの読み取り・書き込み両方
- 例: Google Calendar イベント作成・更新

**Level 3 - リアルタイム連携**:
- Webhook・Push通知での即座同期
- 例: Slack メッセージのリアルタイム受信

## 3. アーキテクチャ設計

### 3.1 全体アーキテクチャ

```
┌─────────────────────────────────────────────────────────────┐
│                 External Services                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │   Google    │  │    Slack    │  │ Microsoft   │         │
│  │ APIs        │  │    API      │  │    Graph    │   ...   │
│  │ • Calendar  │  │             │  │    API      │         │
│  │ • Gmail     │  │             │  │             │         │
│  │ • Tasks     │  │             │  │             │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└─────────────┬───────────┬───────────┬─────────────────────────┘
              │           │           │
         ┌────▼───┐  ┌────▼───┐  ┌────▼───┐
         │OAuth2.0│  │API Keys│  │Webhook │
         │  Flow  │  │        │  │        │
         └────┬───┘  └────┬───┘  └────┬───┘
              │           │           │
┌─────────────▼───────────▼───────────▼─────────────┐
│              myJarvis BFF Server                  │
│                                                   │
│ ┌─────────────────────────────────────────────┐   │
│ │         Integration Gateway                  │   │
│ │                                             │   │
│ │ ┌─────────────┐  ┌─────────────┐           │   │
│ │ │   Service   │  │    Rate     │           │   │
│ │ │  Adapter    │  │  Limiter    │           │   │
│ │ │  Registry   │  │             │           │   │
│ │ └─────────────┘  └─────────────┘           │   │
│ │                                             │   │
│ │ ┌─────────────┐  ┌─────────────┐           │   │
│ │ │   Auth      │  │    Data     │           │   │
│ │ │  Manager    │  │ Normalizer  │           │   │
│ │ └─────────────┘  └─────────────┘           │   │
│ └─────────────────────────────────────────────┘   │
│                                                   │
│ ┌─────────────────────────────────────────────┐   │
│ │         Sync Engine                         │   │
│ │                                             │   │
│ │ ┌─────────────┐  ┌─────────────┐           │   │
│ │ │ Job Queue   │  │   Webhook   │           │   │
│ │ │ (Bull/Bee)  │  │  Processor  │           │   │
│ │ └─────────────┘  └─────────────┘           │   │
│ │                                             │   │
│ │ ┌─────────────┐  ┌─────────────┐           │   │
│ │ │ Retry Logic │  │  Conflict   │           │   │
│ │ │             │  │ Resolution  │           │   │
│ │ └─────────────┘  └─────────────┘           │   │
│ └─────────────────────────────────────────────┘   │
└───────────────────┬───────────────────────────────┘
                    │
          ┌─────────▼─────────┐
          │   Redis Cluster   │
          │                   │
          │ • Job Queue       │
          │ • Cache           │
          │ • Session Store   │
          └───────────────────┘
                    │
          ┌─────────▼─────────┐
          │   PostgreSQL      │
          │                   │
          │ • Integration     │
          │   Settings        │
          │ • Sync Jobs       │
          │ • Audit Logs      │
          └───────────────────┘
```

### 3.2 Service Adapter パターン

各外部サービスに対してアダプタークラスを実装し、統一的なインターフェースを提供：

```typescript
// 基底インターフェース
interface ServiceAdapter {
  readonly serviceName: string;
  readonly version: string;

  // 認証・認可
  authenticate(credentials: AuthCredentials): Promise<AuthResult>;
  refreshToken(refreshToken: string): Promise<TokenResult>;
  revokeAccess(userId: string): Promise<void>;

  // データ同期
  syncData(request: SyncRequest): Promise<SyncResult>;
  validateWebhook(payload: any, signature: string): boolean;
  processWebhook(payload: any): Promise<WebhookResult>;

  // ヘルスチェック
  checkHealth(): Promise<HealthStatus>;
}

// Google Calendar アダプター実装
class GoogleCalendarAdapter implements ServiceAdapter {
  readonly serviceName = 'google_calendar';
  readonly version = '1.0';

  private readonly oauth2Client: OAuth2Client;
  private readonly calendar: calendar_v3.Calendar;

  constructor() {
    this.oauth2Client = new google.auth.OAuth2(
      process.env.GOOGLE_CLIENT_ID,
      process.env.GOOGLE_CLIENT_SECRET,
      process.env.GOOGLE_REDIRECT_URI
    );

    this.calendar = google.calendar({ version: 'v3', auth: this.oauth2Client });
  }

  async authenticate(credentials: AuthCredentials): Promise<AuthResult> {
    try {
      const { tokens } = await this.oauth2Client.getToken(credentials.code);

      // トークンの暗号化保存
      const encryptedTokens = await this.encryptTokens(tokens);

      return {
        success: true,
        userId: await this.getUserId(tokens),
        tokens: encryptedTokens,
        scopes: tokens.scope?.split(' ') || [],
        expiresAt: new Date(tokens.expiry_date || 0)
      };
    } catch (error) {
      logger.error('Google Calendar authentication failed', { error });
      return {
        success: false,
        error: 'AUTHENTICATION_FAILED',
        message: error.message
      };
    }
  }

  async syncData(request: SyncRequest): Promise<SyncResult> {
    const { userId, lastSyncCursor, maxResults = 100 } = request;

    try {
      // ユーザーの認証情報取得・復号化
      const tokens = await this.getDecryptedTokens(userId);
      this.oauth2Client.setCredentials(tokens);

      // カレンダーイベント取得
      const response = await this.calendar.events.list({
        calendarId: 'primary',
        timeMin: lastSyncCursor || new Date().toISOString(),
        maxResults,
        singleEvents: true,
        orderBy: 'startTime'
      });

      // データ正規化
      const normalizedEvents = response.data.items?.map(this.normalizeEvent) || [];

      return {
        success: true,
        data: normalizedEvents,
        nextCursor: this.getNextSyncCursor(response),
        totalProcessed: normalizedEvents.length,
        hasMore: !!response.data.nextPageToken
      };
    } catch (error) {
      if (error.status === 401) {
        // トークン期限切れ - リフレッシュ試行
        return await this.retryWithTokenRefresh(userId, () => this.syncData(request));
      }

      logger.error('Google Calendar sync failed', { userId, error });
      return {
        success: false,
        error: 'SYNC_FAILED',
        message: error.message,
        retryable: this.isRetryableError(error)
      };
    }
  }

  private normalizeEvent(event: calendar_v3.Schema$Event): NormalizedEvent {
    return {
      id: event.id!,
      title: event.summary || 'No Title',
      description: event.description,
      startTime: new Date(event.start?.dateTime || event.start?.date!),
      endTime: new Date(event.end?.dateTime || event.end?.date!),
      location: event.location,
      attendees: event.attendees?.map(a => ({
        email: a.email!,
        name: a.displayName,
        status: a.responseStatus
      })) || [],
      source: {
        service: this.serviceName,
        originalId: event.id!,
        lastModified: new Date(event.updated!)
      }
    };
  }
}
```

## 4. 認証・認可システム

### 4.1 OAuth 2.0 フロー

```typescript
class OAuthManager {
  async initiateAuth(userId: string, service: string): Promise<AuthInitResult> {
    const adapter = this.serviceRegistry.getAdapter(service);
    const state = this.generateSecureState(userId, service);

    // 状態をRedisに一時保存
    await this.redis.setex(`oauth_state:${state}`, 600, JSON.stringify({
      userId,
      service,
      createdAt: new Date().toISOString()
    }));

    const authUrl = adapter.getAuthUrl({
      state,
      scopes: this.getRequiredScopes(service),
      accessType: 'offline', // リフレッシュトークン取得
      prompt: 'consent'
    });

    return {
      authUrl,
      state,
      expiresIn: 600 // 10分
    };
  }

  async handleCallback(code: string, state: string): Promise<CallbackResult> {
    // 状態検証
    const stateData = await this.redis.get(`oauth_state:${state}`);
    if (!stateData) {
      throw new Error('Invalid or expired state parameter');
    }

    const { userId, service } = JSON.parse(stateData);
    await this.redis.del(`oauth_state:${state}`);

    const adapter = this.serviceRegistry.getAdapter(service);

    // 認証実行
    const authResult = await adapter.authenticate({ code, state });

    if (authResult.success) {
      // データベースに保存
      await this.saveIntegration({
        userId,
        service,
        ...authResult
      });

      // 初回同期をキューに追加
      await this.syncQueue.add('initial_sync', {
        userId,
        service,
        syncType: 'full'
      });
    }

    return authResult;
  }

  private async saveIntegration(data: IntegrationData): Promise<void> {
    await this.db.query(`
      INSERT INTO service_integrations (
        user_id, service_type, service_user_id,
        encrypted_access_token, encrypted_refresh_token, token_expires_at,
        granted_scopes, status, created_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW())
      ON CONFLICT (user_id, service_type)
      DO UPDATE SET
        encrypted_access_token = $4,
        encrypted_refresh_token = $5,
        token_expires_at = $6,
        granted_scopes = $7,
        updated_at = NOW()
    `, [
      data.userId,
      data.service,
      data.serviceUserId,
      await this.encryptToken(data.accessToken),
      await this.encryptToken(data.refreshToken),
      data.expiresAt,
      data.scopes,
      'active'
    ]);
  }
}
```

### 4.2 トークン管理・セキュリティ

```typescript
class TokenManager {
  private readonly encryptionKey: string;
  private readonly algorithm = 'aes-256-gcm';

  constructor() {
    this.encryptionKey = process.env.TOKEN_ENCRYPTION_KEY!;
    if (!this.encryptionKey) {
      throw new Error('TOKEN_ENCRYPTION_KEY is required');
    }
  }

  async encryptToken(token: string): Promise<string> {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher(this.algorithm, this.encryptionKey);
    cipher.setAAD(Buffer.from('myjarvis-tokens'));

    let encrypted = cipher.update(token, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    const authTag = cipher.getAuthTag();

    return JSON.stringify({
      encrypted,
      iv: iv.toString('hex'),
      authTag: authTag.toString('hex')
    });
  }

  async decryptToken(encryptedData: string): Promise<string> {
    const { encrypted, iv, authTag } = JSON.parse(encryptedData);

    const decipher = crypto.createDecipher(this.algorithm, this.encryptionKey);
    decipher.setAAD(Buffer.from('myjarvis-tokens'));
    decipher.setAuthTag(Buffer.from(authTag, 'hex'));

    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }

  async refreshTokenIfNeeded(userId: string, service: string): Promise<boolean> {
    const integration = await this.getIntegration(userId, service);

    if (!integration || !this.isTokenExpiringSoon(integration.tokenExpiresAt)) {
      return false;
    }

    const adapter = this.serviceRegistry.getAdapter(service);
    const refreshToken = await this.decryptToken(integration.encryptedRefreshToken);

    try {
      const result = await adapter.refreshToken(refreshToken);

      if (result.success) {
        await this.updateTokens(userId, service, result.tokens);
        return true;
      }
    } catch (error) {
      logger.error('Token refresh failed', { userId, service, error });

      // リフレッシュ失敗時は再認証が必要
      await this.markIntegrationAsExpired(userId, service);
      throw new Error('REAUTH_REQUIRED');
    }

    return false;
  }

  private isTokenExpiringSoon(expiresAt: Date): boolean {
    const now = new Date();
    const expirationThreshold = new Date(now.getTime() + 5 * 60 * 1000); // 5分前
    return expiresAt <= expirationThreshold;
  }
}
```

## 5. データ同期エンジン

### 5.1 同期ジョブ管理

```typescript
// Bull Queue を使用した同期ジョブ管理
class SyncEngine {
  private readonly syncQueue: Queue;
  private readonly retryOptions = {
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 2000
    }
  };

  constructor() {
    this.syncQueue = new Bull('sync-jobs', {
      redis: {
        host: process.env.REDIS_HOST,
        port: parseInt(process.env.REDIS_PORT!),
        password: process.env.REDIS_PASSWORD
      },
      defaultJobOptions: {
        removeOnComplete: 100,
        removeOnFail: 50,
        ...this.retryOptions
      }
    });

    this.setupProcessors();
  }

  private setupProcessors(): void {
    // フル同期プロセッサ
    this.syncQueue.process('full_sync', 5, this.processFULLSync.bind(this));

    // 増分同期プロセッサ
    this.syncQueue.process('incremental_sync', 10, this.processIncrementalSync.bind(this));

    // Webhook プロセッサ
    this.syncQueue.process('webhook', 20, this.processWebhook.bind(this));
  }

  async scheduleSync(userId: string, service: string, type: SyncType = 'incremental'): Promise<void> {
    const jobData: SyncJobData = {
      userId,
      service,
      type,
      requestedAt: new Date().toISOString()
    };

    // 重複ジョブの回避
    const existingJob = await this.syncQueue.getJob(`${userId}:${service}:${type}`);
    if (existingJob && ['waiting', 'active'].includes(await existingJob.getState())) {
      logger.info('Sync job already queued, skipping', { userId, service, type });
      return;
    }

    await this.syncQueue.add(type, jobData, {
      jobId: `${userId}:${service}:${type}`,
      delay: type === 'incremental' ? 0 : 1000 // フル同期は少し遅延させる
    });

    logger.info('Sync job scheduled', { userId, service, type });
  }

  private async processFULLSync(job: Job<SyncJobData>): Promise<SyncResult> {
    const { userId, service } = job.data;

    try {
      // 同期開始をDBに記録
      const syncJobId = await this.recordSyncStart(userId, service, 'full');

      const adapter = this.serviceRegistry.getAdapter(service);

      // 全データ同期
      let allResults: any[] = [];
      let nextCursor: string | undefined;
      let totalProcessed = 0;

      do {
        const result = await adapter.syncData({
          userId,
          syncType: 'full',
          lastSyncCursor: nextCursor,
          maxResults: 1000
        });

        if (!result.success) {
          throw new Error(result.message);
        }

        allResults = allResults.concat(result.data);
        nextCursor = result.nextCursor;
        totalProcessed += result.totalProcessed;

        // プログレス更新
        await this.updateSyncProgress(syncJobId, {
          processed: totalProcessed,
          hasMore: result.hasMore
        });

        // 進行状況をジョブに反映
        job.progress(Math.min(95, (totalProcessed / (totalProcessed + 100)) * 100));

      } while (nextCursor);

      // データを正規化して保存
      const savedCount = await this.saveNormalizedData(userId, service, allResults);

      // 同期完了を記録
      await this.recordSyncCompletion(syncJobId, {
        totalProcessed,
        savedCount,
        status: 'completed'
      });

      return {
        success: true,
        totalProcessed,
        savedCount
      };

    } catch (error) {
      logger.error('Full sync failed', { userId, service, error });
      throw error; // Bull が自動的にリトライを処理
    }
  }

  private async processIncrementalSync(job: Job<SyncJobData>): Promise<SyncResult> {
    const { userId, service } = job.data;

    try {
      const lastSyncCursor = await this.getLastSyncCursor(userId, service);
      const adapter = this.serviceRegistry.getAdapter(service);

      const result = await adapter.syncData({
        userId,
        syncType: 'incremental',
        lastSyncCursor,
        maxResults: 500
      });

      if (!result.success) {
        throw new Error(result.message);
      }

      if (result.data.length > 0) {
        await this.saveNormalizedData(userId, service, result.data);
        await this.updateLastSyncCursor(userId, service, result.nextCursor);

        // リアルタイム通知
        await this.notifyClients(userId, {
          type: 'sync_update',
          service,
          updatedItems: result.data.length
        });
      }

      return result;

    } catch (error) {
      logger.error('Incremental sync failed', { userId, service, error });
      throw error;
    }
  }
}
```

### 5.2 Webhook処理

```typescript
class WebhookProcessor {
  async processGoogleCalendarWebhook(payload: any): Promise<WebhookResult> {
    const { resourceId, channelId } = payload;

    // チャネルIDからユーザーIDを逆引き
    const userId = await this.getUserIdFromChannel(channelId);
    if (!userId) {
      return { success: false, error: 'Unknown channel' };
    }

    // 変更されたリソースの詳細を取得
    const adapter = this.serviceRegistry.getAdapter('google_calendar');
    const syncResult = await adapter.syncData({
      userId,
      syncType: 'webhook',
      resourceId
    });

    if (syncResult.success && syncResult.data.length > 0) {
      // リアルタイムでクライアントに通知
      await this.wsManager.notifyUser(userId, {
        type: 'calendar_update',
        data: syncResult.data
      });
    }

    return { success: true };
  }

  async processSlackWebhook(payload: any): Promise<WebhookResult> {
    const { event, team_id } = payload;

    // チームIDからユーザーIDを取得
    const userId = await this.getUserIdFromSlackTeam(team_id);
    if (!userId) {
      return { success: false, error: 'Unknown team' };
    }

    switch (event.type) {
      case 'message':
        return await this.processSlackMessage(userId, event);

      case 'app_mention':
        return await this.processSlackMention(userId, event);

      default:
        return { success: true, message: 'Event ignored' };
    }
  }

  private async processSlackMessage(userId: string, event: any): Promise<WebhookResult> {
    // メッセージからタスクを抽出する処理
    const possibleTask = await this.llmProcessor.extractTaskFromMessage(event.text);

    if (possibleTask.confidence > 0.7) {
      // 高い確信度でタスクと判定された場合、ユーザーに提案
      await this.wsManager.notifyUser(userId, {
        type: 'task_suggestion',
        data: {
          source: 'slack',
          message: event.text,
          suggestedTask: possibleTask.task
        }
      });
    }

    return { success: true };
  }
}
```

## 6. エラーハンドリング・復旧

### 6.1 エラー分類と処理

```typescript
enum IntegrationErrorType {
  // 一時的なエラー（再試行可能）
  RATE_LIMITED = 'RATE_LIMITED',
  NETWORK_ERROR = 'NETWORK_ERROR',
  SERVICE_UNAVAILABLE = 'SERVICE_UNAVAILABLE',
  TIMEOUT = 'TIMEOUT',

  // 認証エラー（ユーザー操作が必要）
  TOKEN_EXPIRED = 'TOKEN_EXPIRED',
  INSUFFICIENT_PERMISSIONS = 'INSUFFICIENT_PERMISSIONS',
  ACCOUNT_SUSPENDED = 'ACCOUNT_SUSPENDED',

  // 設定エラー（システム修正が必要）
  INVALID_CREDENTIALS = 'INVALID_CREDENTIALS',
  UNSUPPORTED_OPERATION = 'UNSUPPORTED_OPERATION',
  DATA_FORMAT_ERROR = 'DATA_FORMAT_ERROR'
}

class IntegrationErrorHandler {
  async handleError(error: any, context: ErrorContext): Promise<ErrorHandlingResult> {
    const errorType = this.classifyError(error);

    switch (errorType) {
      case IntegrationErrorType.RATE_LIMITED:
        return await this.handleRateLimit(error, context);

      case IntegrationErrorType.TOKEN_EXPIRED:
        return await this.handleTokenExpiry(error, context);

      case IntegrationErrorType.NETWORK_ERROR:
        return await this.handleNetworkError(error, context);

      default:
        return await this.handleGenericError(error, context);
    }
  }

  private async handleRateLimit(error: any, context: ErrorContext): Promise<ErrorHandlingResult> {
    const retryAfter = this.extractRetryAfter(error) || 60; // デフォルト1分

    // レート制限をRedisに記録
    await this.recordRateLimit(context.service, retryAfter);

    return {
      shouldRetry: true,
      retryAfter: retryAfter * 1000, // ミリ秒
      errorLevel: 'warning',
      userMessage: `${context.service}のレート制限により、${retryAfter}秒後に再試行します。`
    };
  }

  private async handleTokenExpiry(error: any, context: ErrorContext): Promise<ErrorHandlingResult> {
    try {
      // トークンリフレッシュ試行
      const refreshed = await this.tokenManager.refreshTokenIfNeeded(
        context.userId,
        context.service
      );

      if (refreshed) {
        return {
          shouldRetry: true,
          retryAfter: 1000, // 1秒後に再試行
          errorLevel: 'info',
          userMessage: '認証情報を更新しました。'
        };
      }
    } catch (refreshError) {
      // リフレッシュ失敗 - 再認証が必要
      await this.notifyReauthRequired(context.userId, context.service);
    }

    return {
      shouldRetry: false,
      errorLevel: 'error',
      userMessage: `${context.service}の認証が期限切れです。再度連携設定を行ってください。`,
      requiresUserAction: true
    };
  }
}
```

### 6.2 回復性戦略

```typescript
class ResilienceManager {
  private readonly circuitBreakers = new Map<string, CircuitBreaker>();

  getCircuitBreaker(service: string): CircuitBreaker {
    if (!this.circuitBreakers.has(service)) {
      this.circuitBreakers.set(service, new CircuitBreaker({
        timeout: 30000, // 30秒タイムアウト
        errorThresholdPercentage: 50,
        resetTimeout: 60000, // 1分で回復試行
        rollingCountTimeout: 10000, // 10秒間のウィンドウ
        rollingCountBuckets: 10
      }));
    }

    return this.circuitBreakers.get(service)!;
  }

  async executeWithResilience<T>(
    service: string,
    operation: () => Promise<T>
  ): Promise<T> {
    const circuitBreaker = this.getCircuitBreaker(service);

    return await circuitBreaker.fire(async () => {
      // バルクヘッド パターン - 同期処理の並行度制限
      return await this.semaphore.acquire(service, operation);
    });
  }

  async executeWithFallback<T>(
    primary: () => Promise<T>,
    fallback: () => Promise<T>,
    service: string
  ): Promise<T> {
    try {
      return await this.executeWithResilience(service, primary);
    } catch (error) {
      logger.warn(`Primary operation failed for ${service}, using fallback`, { error });
      return await fallback();
    }
  }
}

// 使用例
class GoogleCalendarAdapter implements ServiceAdapter {
  async syncData(request: SyncRequest): Promise<SyncResult> {
    return await this.resilienceManager.executeWithFallback(
      // プライマリ: APIから最新データ取得
      () => this.fetchFromAPI(request),
      // フォールバック: キャッシュからデータ取得
      () => this.fetchFromCache(request),
      'google_calendar'
    );
  }
}
```

## 7. パフォーマンス最適化

### 7.1 キャッシング戦略

```typescript
class IntegrationCacheManager {
  private readonly redis: Redis;

  // レスポンスキャッシュ
  async cacheResponse(key: string, data: any, ttl: number = 300): Promise<void> {
    await this.redis.setex(
      `integration:cache:${key}`,
      ttl,
      JSON.stringify(data)
    );
  }

  async getCachedResponse<T>(key: string): Promise<T | null> {
    const cached = await this.redis.get(`integration:cache:${key}`);
    return cached ? JSON.parse(cached) : null;
  }

  // APIレート制限状況のキャッシュ
  async setRateLimit(service: string, resetTime: number): Promise<void> {
    await this.redis.setex(
      `rate_limit:${service}`,
      Math.max(1, resetTime - Date.now() / 1000),
      '1'
    );
  }

  async isRateLimited(service: string): Promise<boolean> {
    return (await this.redis.get(`rate_limit:${service}`)) !== null;
  }

  // 差分同期のためのETag管理
  async storeETag(userId: string, service: string, resource: string, etag: string): Promise<void> {
    await this.redis.hset(
      `etags:${userId}:${service}`,
      resource,
      etag
    );
  }

  async getETag(userId: string, service: string, resource: string): Promise<string | null> {
    return await this.redis.hget(`etags:${userId}:${service}`, resource);
  }
}
```

### 7.2 バッチ処理最適化

```typescript
class BatchProcessor {
  async processBatch<T>(
    items: T[],
    processor: (batch: T[]) => Promise<void>,
    batchSize: number = 100
  ): Promise<void> {
    const batches = this.chunkArray(items, batchSize);

    // 並列実行（制限付き）
    await pMap(
      batches,
      processor,
      { concurrency: 3 } // 最大3つのバッチを並行処理
    );
  }

  // Google Calendar の複数イベント一括作成
  async createEventsInBatch(
    userId: string,
    events: CalendarEvent[]
  ): Promise<BatchResult> {
    const adapter = this.serviceRegistry.getAdapter('google_calendar');
    const results: EventCreationResult[] = [];

    await this.processBatch(
      events,
      async (eventBatch) => {
        // Google Calendar Batch API使用
        const batchRequest = new google.calendar.Calendar(adapter.auth);

        const batchPromises = eventBatch.map(event =>
          batchRequest.events.insert({
            calendarId: 'primary',
            requestBody: this.convertToGoogleFormat(event)
          })
        );

        try {
          const batchResults = await Promise.allSettled(batchPromises);
          results.push(...this.processBatchResults(batchResults));
        } catch (error) {
          logger.error('Batch event creation failed', { userId, error });
          throw error;
        }
      },
      10 // Google Calendar APIの制限に合わせてバッチサイズを調整
    );

    return {
      success: results.every(r => r.success),
      totalProcessed: results.length,
      errors: results.filter(r => !r.success)
    };
  }

  private chunkArray<T>(array: T[], size: number): T[][] {
    return Array.from(
      { length: Math.ceil(array.length / size) },
      (_, index) => array.slice(index * size, index * size + size)
    );
  }
}
```

## 8. 監視・運用

### 8.1 メトリクス収集

```typescript
// Prometheus メトリクス定義
class IntegrationMetrics {
  private readonly syncDuration = new prometheus.Histogram({
    name: 'integration_sync_duration_seconds',
    help: 'Time spent on sync operations',
    labelNames: ['service', 'sync_type', 'status']
  });

  private readonly apiCalls = new prometheus.Counter({
    name: 'integration_api_calls_total',
    help: 'Total number of external API calls',
    labelNames: ['service', 'endpoint', 'status']
  });

  private readonly rateLimits = new prometheus.Gauge({
    name: 'integration_rate_limit_remaining',
    help: 'Remaining API rate limit',
    labelNames: ['service']
  });

  private readonly syncErrors = new prometheus.Counter({
    name: 'integration_sync_errors_total',
    help: 'Total number of sync errors',
    labelNames: ['service', 'error_type']
  });

  recordSyncDuration(service: string, type: string, duration: number, success: boolean): void {
    this.syncDuration
      .labels(service, type, success ? 'success' : 'error')
      .observe(duration);
  }

  recordAPICall(service: string, endpoint: string, statusCode: number): void {
    this.apiCalls
      .labels(service, endpoint, statusCode >= 400 ? 'error' : 'success')
      .inc();
  }

  updateRateLimit(service: string, remaining: number): void {
    this.rateLimits.labels(service).set(remaining);
  }

  recordSyncError(service: string, errorType: string): void {
    this.syncErrors.labels(service, errorType).inc();
  }
}
```

### 8.2 ヘルスチェック

```typescript
class IntegrationHealthChecker {
  async checkAllServices(): Promise<HealthCheckResult> {
    const services = this.serviceRegistry.getAllServices();
    const results = await Promise.allSettled(
      services.map(service => this.checkServiceHealth(service))
    );

    const healthResults = results.map((result, index) => ({
      service: services[index],
      status: result.status === 'fulfilled' ? result.value : 'unhealthy',
      error: result.status === 'rejected' ? result.reason.message : null
    }));

    return {
      overall: healthResults.every(r => r.status === 'healthy') ? 'healthy' : 'degraded',
      services: healthResults,
      timestamp: new Date().toISOString()
    };
  }

  private async checkServiceHealth(service: string): Promise<'healthy' | 'unhealthy'> {
    try {
      const adapter = this.serviceRegistry.getAdapter(service);
      const result = await adapter.checkHealth();

      return result.status === 'healthy' ? 'healthy' : 'unhealthy';
    } catch (error) {
      logger.error(`Health check failed for ${service}`, { error });
      return 'unhealthy';
    }
  }

  // Express ヘルスチェックエンドポイント
  setupHealthEndpoint(app: Express): void {
    app.get('/health/integrations', async (req, res) => {
      const health = await this.checkAllServices();

      res.status(health.overall === 'healthy' ? 200 : 503).json(health);
    });
  }
}
```

### 8.3 アラート設定

```yaml
# Prometheus アラートルール例
groups:
  - name: integration_alerts
    rules:
      - alert: IntegrationSyncFailureRate
        expr: |
          (
            rate(integration_sync_errors_total[5m]) /
            rate(integration_api_calls_total[5m])
          ) > 0.1
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "High integration sync failure rate"
          description: "Integration {{ $labels.service }} has >10% failure rate"

      - alert: IntegrationRateLimitExhausted
        expr: integration_rate_limit_remaining < 100
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Integration rate limit nearly exhausted"
          description: "{{ $labels.service }} has only {{ $value }} API calls remaining"

      - alert: IntegrationSyncLag
        expr: |
          (time() - integration_last_successful_sync_timestamp) > 3600
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "Integration sync lag detected"
          description: "{{ $labels.service }} hasn't synced successfully for over 1 hour"
```

## 9. セキュリティ考慮事項

### 9.1 データ保護

```typescript
class DataProtectionManager {
  // 個人情報のマスキング（LLM送信前）
  maskSensitiveData(data: any): any {
    const sensitiveFields = [
      'email', 'phone', 'address', 'ssn', 'credit_card'
    ];

    return this.deepTransform(data, (key, value) => {
      if (sensitiveFields.some(field => key.toLowerCase().includes(field))) {
        return this.maskValue(value);
      }
      return value;
    });
  }

  private maskValue(value: string): string {
    if (!value || typeof value !== 'string') return value;

    // メールアドレスのマスキング
    if (value.includes('@')) {
      const [local, domain] = value.split('@');
      return `${local.slice(0, 2)}***@${domain}`;
    }

    // その他の文字列のマスキング
    if (value.length > 4) {
      return `${value.slice(0, 2)}${'*'.repeat(value.length - 4)}${value.slice(-2)}`;
    }

    return '*'.repeat(value.length);
  }

  // データ保持期間の管理
  async cleanupExpiredData(): Promise<void> {
    // 90日より古い同期ログを削除
    await this.db.query(`
      DELETE FROM sync_jobs
      WHERE created_at < NOW() - INTERVAL '90 days'
    `);

    // 期限切れの認証トークンを削除
    await this.db.query(`
      DELETE FROM service_integrations
      WHERE status = 'expired'
      AND updated_at < NOW() - INTERVAL '30 days'
    `);
  }
}
```

### 9.2 監査ログ

```typescript
class IntegrationAuditLogger {
  async logIntegrationEvent(event: AuditEvent): Promise<void> {
    await this.db.query(`
      INSERT INTO integration_audit_logs (
        user_id, service_type, action, resource_type, resource_id,
        old_values, new_values, ip_address, user_agent, created_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW())
    `, [
      event.userId,
      event.service,
      event.action,
      event.resourceType,
      event.resourceId,
      JSON.stringify(event.oldValues),
      JSON.stringify(event.newValues),
      event.ipAddress,
      event.userAgent
    ]);

    // 重要なイベントは別途アラート
    if (this.isCriticalEvent(event)) {
      await this.sendSecurityAlert(event);
    }
  }

  private isCriticalEvent(event: AuditEvent): boolean {
    const criticalActions = [
      'integration_connected',
      'integration_disconnected',
      'token_refreshed',
      'permission_escalated'
    ];

    return criticalActions.includes(event.action);
  }
}
```

## 10. 実装考慮事項

### 10.1 開発フェーズ

**Phase 1 (3ヶ月)**:
- Google Calendar・Gmail基本連携
- OAuth2.0認証フロー
- 基本的な同期機能

**Phase 2 (2ヶ月)**:
- Slack連携
- Webhook処理
- エラーハンドリング強化

**Phase 3 (2ヶ月)**:
- Microsoft 365連携
- バッチ処理最適化
- 高度なキャッシング

**Phase 4 (継続)**:
- 追加サービス対応
- 運用最適化
- セキュリティ強化

### 10.2 テスト戦略

```typescript
// 統合テスト例
describe('Google Calendar Integration', () => {
  let adapter: GoogleCalendarAdapter;
  let mockGoogleAPI: jest.MockedFunction<any>;

  beforeEach(() => {
    mockGoogleAPI = jest.fn();
    adapter = new GoogleCalendarAdapter();
  });

  it('should sync calendar events successfully', async () => {
    const mockEvents = [
      { id: 'event1', summary: 'Meeting', start: { dateTime: '2025-09-25T10:00:00Z' } }
    ];

    mockGoogleAPI.mockResolvedValueOnce({
      data: { items: mockEvents }
    });

    const result = await adapter.syncData({
      userId: 'test-user',
      syncType: 'incremental'
    });

    expect(result.success).toBe(true);
    expect(result.data).toHaveLength(1);
    expect(result.data[0].title).toBe('Meeting');
  });

  it('should handle rate limiting gracefully', async () => {
    mockGoogleAPI.mockRejectedValueOnce({
      status: 429,
      message: 'Rate limit exceeded',
      headers: { 'retry-after': '60' }
    });

    await expect(adapter.syncData({
      userId: 'test-user',
      syncType: 'incremental'
    })).rejects.toThrow('Rate limit exceeded');

    // レート制限情報がキャッシュされることを確認
    expect(await adapter.isRateLimited()).toBe(true);
  });
});
```

## 11. 関連文書

- [01-システムアーキテクチャ設計](/docs/design/01-システムアーキテクチャ設計.md)
- [02-API設計](/docs/design/02-API設計.md)
- [06-セキュリティ・プライバシー設計](/docs/design/06-セキュリティ・プライバシー設計.md)
- [ADR-002: 外部サービス統合戦略](/docs/adr/ADR-002-外部サービス統合戦略.md)

---

*この設計書は、myJarvis システムの外部サービス統合における包括的な設計仕様を提供し、セキュアで拡張可能な統合アーキテクチャの実現を支援します。*