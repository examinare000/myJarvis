# ADR-006: リアルタイム同期戦略

**ステータス:** 承認済み
**日付:** 2025-09-25
**意思決定者:** 開発チーム

## コンテキスト

ユーザーがWebアプリでタスクを完了したら、即座にiPhoneアプリにもその状態が反映される必要があります。このようなリアルタイムなデータ同期は、シームレスなマルチデバイス体験の実現に不可欠です。

## 要求事項
- デバイス間でのリアルタイムなデータ同期
- オフライン時の動作継続とオンライン復帰時の整合性確保
- ネットワーク効率性とバッテリー消費の最適化
- 競合状態（複数デバイスでの同時更新）の適切な処理
- スケーラビリティの確保

## 検討した選択肢

### 1. 定期ポーリング (Polling)
- **概要**: クライアントが一定間隔（例: 30秒ごと）でサーバーに更新がないか問い合わせ
- **長所**:
  - 実装が比較的容易
  - サーバーサイドの負荷が予測可能
  - HTTP基盤で実装可能
- **短所**:
  - リアルタイム性に欠ける（最大ポーリング間隔の遅延）
  - 不要な通信が多く、バッテリー消費・サーバー負荷が高い
  - データ更新がない場合の無駄なトラフィック

### 2. ロングポーリング (Long Polling)
- **概要**: クライアントがサーバーに問い合わせ、サーバーは更新があるまでレスポンスを保留
- **長所**:
  - ポーリングよりは効率的
  - HTTP基盤で実装可能
  - リアルタイム性の向上
- **短所**:
  - サーバー側の負荷が依然として高い（多数の開いた接続）
  - タイムアウト処理の複雑性
  - プロキシ・ファイアウォールでの問題

### 3. WebSockets / Server-Sent Events
- **概要**: サーバーとクライアント間で永続的な双方向/単方向コネクションを確立し、リアルタイム通信
- **長所**:
  - 真のリアルタイム通信が可能
  - 通信のオーバーヘッドが少ない
  - 双方向通信（WebSockets）によるインタラクティブな操作
- **短所**:
  - 状態を持つコネクションの管理が必要
  - サーバー実装が複雑
  - スケーリング時の考慮事項が多い

## 決定

**WebSockets を採用します。**

### 決定理由

1. **最高のユーザー体験**: データが変更されると即座に全ての接続済みクライアントに更新がプッシュされ、遅延のないシームレスな体験を実現
2. **双方向通信**: WebSocketsは双方向通信をサポートしており、クライアントからのデータ送信とサーバーからのプッシュを同じコネクションで効率的に処理
3. **効率性**: 一度コネクションを確立すれば、HTTPヘッダーのオーバーヘッドなしに小さなデータをやり取り可能

## アーキテクチャ設計

### システム構成図

```
[iOS Client] ←→ [WebSocket] ←→ [Node.js BFF] ←→ [Redis Pub/Sub] ←→ [External APIs]
     ↓              ↓              ↓               ↓
[Local Cache] [Connection     [Event Handler]  [Message Queue]
              Manager]

[Web Client] ←→ [WebSocket] ←→ [Node.js BFF] ←→ [Database] ←→ [Background Jobs]
     ↓              ↓              ↓          ↓
[Local Cache] [Connection     [State Sync]  [Data Store]
              Manager]
```

### WebSocket通信フロー

#### 1. 接続確立フェーズ
```
Client → Server: WebSocket Handshake + Auth Token
Server → Client: Connection Accepted + Initial State Sync
Server → Client: Subscription Confirmation
```

#### 2. リアルタイム更新フェーズ
```
External Event → BFF → Redis Pub/Sub → All Connected Clients
    ↓              ↓         ↓              ↓
Calendar Update  Process   Broadcast    Display Update
Task Completion  Event     Message      Sync State
```

#### 3. 衝突解決フェーズ
```
Client A → Server: Update Request (with version)
Client B → Server: Concurrent Update Request (with version)
Server → Client A: Success
Server → Client B: Conflict (latest version)
Client B → User: Merge Conflict Resolution UI
```

## 技術実装詳細

### サーバーサイド（Node.js BFF）

#### WebSocketサーバー
```typescript
// WebSocket管理クラス
class WebSocketManager {
  - connectionPool: Map<userId, WebSocket[]>
  - subscriptionManager: SubscriptionManager
  - eventProcessor: EventProcessor
}

// イベント処理パイプライン
EventSource → EventProcessor → SubscriptionManager → WebSocket Pool → Clients
```

#### Redis Pub/Sub統合
- **Publisher**: 外部APIイベント、データベース変更の検出時に発行
- **Subscriber**: 各BFFインスタンスが購読し、WebSocketクライアントに配信
- **Channel戦略**: ユーザーごと、データタイプごとのチャネル設計

### クライアントサイド（KMP共有コア）

#### 接続管理
```kotlin
class WebSocketClient {
  - connectionState: StateFlow<ConnectionState>
  - messageQueue: Queue<OutgoingMessage>
  - reconnectionStrategy: ExponentialBackoffStrategy
  - heartbeatManager: HeartbeatManager
}
```

#### オフライン対応
```kotlin
class OfflineSync {
  - pendingChanges: Queue<ChangeEvent>
  - conflictResolution: ConflictResolver
  - optimisticUpdates: OptimisticUpdateManager
}
```

## 同期戦略と衝突解決

### 楽観的同期（Optimistic Sync）
1. **即座のUI更新**: ユーザーのアクションを即座にローカルUIに反映
2. **サーバー確認**: バックグラウンドでサーバーに送信・確認
3. **衝突時の巻き戻し**: サーバーから拒否された場合、UIを元の状態に戻して再同期

### バージョン管理
- **Vector Clocks**: 分散システムでの因果関係を適切に管理
- **Last-Write-Wins**: シンプルな衝突解決（タイムスタンプベース）
- **User-Defined Resolution**: 重要なデータについてはユーザーによる手動解決

### オフライン・オンライン遷移
```
Offline Mode:
  - Queue all changes locally
  - Continue with cached data
  - Show offline indicator

Online Recovery:
  - Establish WebSocket connection
  - Send queued changes with conflict detection
  - Receive and apply server-side changes
  - Resolve any conflicts
  - Update UI with final state
```

## パフォーマンス最適化

### メッセージ最適化
- **Delta Sync**: 差分のみを送信（全体データではなく）
- **Batching**: 短時間内の複数変更をバッチ処理
- **Compression**: WebSocket上でのgzip圧縮有効化
- **Throttling**: 高頻度更新の制限（例：1秒間に最大10メッセージ）

### 接続管理最適化
- **Connection Pooling**: デバイスごとに適切な接続数を維持
- **Keep-Alive**: 定期的なpingによる接続状態確認
- **Graceful Degradation**: WebSocket失敗時のHTTPポーリングへのフォールバック

## スケーラビリティ対応

### 水平スケーリング
- **Sticky Sessions**: ロードバランサーレベルでのセッション固定
- **Redis Cluster**: 複数BFFインスタンス間でのPub/Sub共有
- **Message Routing**: ユーザーIDベースの効率的なメッセージルーティング

### モニタリング
- **Connection Metrics**: アクティブ接続数、接続継続時間
- **Message Metrics**: メッセージレート、レイテンシー、エラー率
- **Conflict Metrics**: 衝突発生頻度、解決時間

## セキュリティ考慮事項

### 認証・認可
- **Token-based Auth**: JWT トークンによる認証
- **Subscription Authorization**: ユーザーが購読権限を持つデータのみ配信
- **Rate Limiting**: 悪用防止のためのメッセージレート制限

### データ保護
- **Encrypted Transport**: WSS（WebSocket over TLS）の強制
- **Payload Encryption**: 機微なデータの追加暗号化
- **Access Logging**: 全ての接続・メッセージアクセスのログ記録

## 影響と結果

### ポジティブな影響
- 真のリアルタイム体験によるユーザーエンゲージメント向上
- 効率的なデータ転送による通信コスト削減
- 複数デバイス間でのシームレスな作業継続
- 競合状態の適切な処理による データ整合性保証

### ネガティブな影響とリスク軽減策
- **実装複雑性**: 段階的な実装とテスト自動化
- **サーバー負荷**: 効率的な接続管理とスケーリング戦略
- **ネットワーク依存**: オフライン機能とフォールバック機能
- **デバッグの困難さ**: 包括的なログとモニタリング

### 成功指標
- **レイテンシー**: データ更新から他デバイスへの反映まで < 500ms
- **可用性**: WebSocket接続成功率 > 99.5%
- **衝突解決**: 自動解決率 > 95%（手動介入を最小化）

## 関連する意思決定
- ADR-001: マルチプラットフォーム戦略（KMP共有でのWebSocketクライアント）
- ADR-002: 外部サービス統合戦略（BFFでのWebSocketサーバー実装）
- ADR-004: 通知システム設計（WebSocket経由のリアルタイム通知）
- ADR-005: データストレージ・プライバシー戦略（同期データの暗号化）